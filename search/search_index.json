{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Odys","text":"<p>Documentation: https://ramirocrc.github.io/odys/</p> <p>Source Code: https://github.com/ramirocrc/odys/</p>"},{"location":"#overview","title":"Overview","text":"<p>Odys is a Python package for optimizing multi-asset energy portfolios across multiple electricity markets using stochastic optimization. It's built on top of Pydantic, linopy, and HiGHS.</p> <p>The key features are:</p> <ul> <li>Simple API - Define your energy system (generators, batteries, loads, markets) and call <code>.optimize()</code>. The mathematical model is built and solved for you under the hood.</li> <li>Pydantic-powered validation - All models use Pydantic with strict typing and validators, so configuration errors get caught early.</li> <li>Stochastic optimization - Optimize across multiple probabilistic scenarios with different prices, capacities, and load profiles to make decisions under uncertainty.</li> <li>Great editor support - Full autocompletion and type checking everywhere, so you spend less time debugging.</li> </ul>"},{"location":"#installation","title":"Installation","text":"pipuv <pre><code>pip install odys\n</code></pre> <pre><code>uv add odys\n</code></pre> <p>Odys requires a recent and currently supported version of Python.</p>"},{"location":"#minimal-example","title":"Minimal Example","text":"<p>A generator and a battery working together to meet a fixed load over 4 hourly timesteps.</p>"},{"location":"#create-it","title":"Create it","text":"<pre><code>from datetime import timedelta\n\nfrom odys.energy_system import EnergySystem\nfrom odys.energy_system_models.assets.generator import PowerGenerator\nfrom odys.energy_system_models.assets.load import Load\nfrom odys.energy_system_models.assets.portfolio import AssetPortfolio\nfrom odys.energy_system_models.assets.storage import Battery\nfrom odys.energy_system_models.scenarios import Scenario\n\n# Define assets\ngenerator = PowerGenerator(\n    name=\"gen\",\n    nominal_power=100.0,\n    variable_cost=50.0,\n)\n\nbattery = Battery(\n    name=\"battery\",\n    capacity=50.0,\n    max_power=25.0,\n    efficiency_charging=0.95,\n    efficiency_discharging=0.95,\n    soc_start=0.5,\n    soc_end=0.5,\n)\n\nload = Load(name=\"demand\")\n\n# Build the portfolio\nportfolio = AssetPortfolio()\nportfolio.add_asset(generator)\nportfolio.add_asset(battery)\nportfolio.add_asset(load)\n\n# Set up the energy system\nenergy_system = EnergySystem(\n    portfolio=portfolio,\n    scenarios=Scenario(\n        load_profiles={\"demand\": [60, 90, 40, 70]},\n    ),\n    timestep=timedelta(hours=1),\n    number_of_steps=4,\n    power_unit=\"MW\",\n)\n</code></pre>"},{"location":"#run-it","title":"Run it","text":"<pre><code>result = energy_system.optimize()\n</code></pre>"},{"location":"#check-it","title":"Check it","text":"<pre><code># Solver status\nprint(result.solver_status)        # \"ok\"\nprint(result.termination_condition) # \"optimal\"\n\n# Generator dispatch\nprint(result.generators.power)\n\n# Battery behavior\nprint(result.batteries.net_power)\nprint(result.batteries.state_of_charge)\n\n# Everything in one DataFrame\nprint(result.to_dataframe)\n</code></pre>"},{"location":"#dependencies","title":"Dependencies","text":"<p>Odys is built on top of these great projects:</p> <ul> <li>Pydantic - Data validation and settings management</li> <li>linopy - Linear optimization modeling</li> <li>HiGHS - High-performance optimization solver</li> <li>pandas - Data analysis and manipulation</li> <li>xarray - Multi-dimensional arrays</li> </ul> <p>All dependencies are installed automatically when you install odys.</p>"},{"location":"#license","title":"License","text":"<p>Odys is licensed under the MIT License.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use odys for a scientific publication, we'd appreciate a citation.</p> <p>BibTeX:</p> <pre><code>@software{odys,\n  author  = {Criach, Ramiro},\n  title   = {odys},\n  version = {0.1.2},\n  month   = {12},\n  year    = {2024},\n  license = {MIT},\n  url     = {https://ramirocrc.github.io/odys/},\n}\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions to odys are welcome and appreciated!</p>"},{"location":"contributing/#issues","title":"Issues","text":"<p>Bug reports, feature requests and general questions can all be filed as issues.</p> <p>When reporting a bug, please include the output of the following call so we can reproduce the problem:</p> <pre><code>python -c \"from importlib.metadata import version; print(version('odys'))\"\n</code></pre>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>Getting started with a pull request is straightforward.</p> <p>For non-trivial changes, please open an issue first to discuss the approach before submitting a PR.</p>"},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<p>Make sure you have the following installed:</p> <ul> <li>Python 3.11 to 3.14</li> <li>uv for dependency management</li> <li>just for running development commands</li> <li>git for version control</li> </ul>"},{"location":"contributing/#installation-and-setup","title":"Installation and setup","text":"<p>Fork the repository on GitHub and clone your fork locally.</p> <pre><code># Clone your fork and cd into the repo directory\ngit clone git@github.com:&lt;your username&gt;/odys.git\ncd odys\n\n# Install dependencies and pre-commit hooks\njust install\n</code></pre>"},{"location":"contributing/#check-out-a-new-branch-and-make-your-changes","title":"Check out a new branch and make your changes","text":"<pre><code>git switch -c my-new-feature-branch\n# Make your changes...\n</code></pre>"},{"location":"contributing/#run-tests-and-linting","title":"Run tests and linting","text":"<p>Before opening a PR, verify that formatting, linting and tests all pass locally.</p> <pre><code># Run automated code formatting and linting\njust check\n\n# Run tests\njust test\n</code></pre>"},{"location":"contributing/#build-documentation","title":"Build documentation","text":"<p>If your changes touch documentation, verify the build still succeeds.</p> <pre><code>just docs-test\n</code></pre>"},{"location":"contributing/#commit-and-push-your-changes","title":"Commit and push your changes","text":"<p>Once everything passes, commit and push your branch.</p> <pre><code>git add .\ngit commit -m \"Your detailed description of your changes.\"\ngit push origin my-new-feature-branch\n</code></pre> <p>Then open a pull request on GitHub. Link any related issues and describe what your changes do.</p>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Please make sure your pull request:</p> <ol> <li>Includes tests for any new or changed behaviour.</li> <li>Updates documentation if it adds new functionality.</li> </ol>"},{"location":"api/","title":"API Reference","text":"<p>Auto-generated reference documentation for the <code>odys</code> package.</p> Module What's in it Energy System <code>EnergySystem</code>, asset models, portfolio, scenarios, markets Optimization <code>OptimizationResults</code> and result containers Math Model MILP model builder, sets, variables, constraints, parameters Solvers HiGHS solver interface"},{"location":"api/energy_system/","title":"Energy System API","text":""},{"location":"api/energy_system/#energysystem","title":"EnergySystem","text":"<p>Energy system configuration and optimization.</p> <p>This module provides the EnergySystem class, the main entry point for configuring and optimizing energy systems.</p>"},{"location":"api/energy_system/#odys.energy_system.EnergySystem","title":"<code>EnergySystem</code>","text":"<p>Energy system configuration and optimization orchestrator.</p> <p>This class provides a high-level interface for configuring and optimizing energy systems. It handles system validation, model building, and optimization execution through external solvers.</p> Source code in <code>src/odys/energy_system.py</code> <pre><code>class EnergySystem:\n    \"\"\"Energy system configuration and optimization orchestrator.\n\n    This class provides a high-level interface for configuring and optimizing\n    energy systems. It handles system validation, model building, and\n    optimization execution through external solvers.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        portfolio: AssetPortfolio,\n        timestep: timedelta,\n        number_of_steps: int,\n        power_unit: str,\n        scenarios: Scenario | Sequence[StochasticScenario],\n        markets: EnergyMarket | Sequence[EnergyMarket] | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the energy system configuration and optimizer.\n\n        Args:\n            portfolio: The portfolio of energy assets (generators, batteries, etc.).\n            timestep: Duration of each time period.\n            number_of_steps: Number of time steps.\n            power_unit: Unit used for power quantities ('W', 'kW', or 'MW').\n            scenarios: Sequence of stochastic scenarios. Probabilities must add up to 1.\n            markets: Optional energy markets in which assets can participate.\n\n        \"\"\"\n        self._validated_model = ValidatedEnergySystem(\n            portfolio=portfolio,\n            markets=markets,\n            timestep=timestep,\n            number_of_steps=number_of_steps,\n            power_unit=power_unit,  # ty: ignore  # pyright: ignore[reportArgumentType]\n            scenarios=scenarios,\n        )\n\n    def optimize(self) -&gt; OptimizationResults:\n        \"\"\"Optimize the energy system.\n\n        This method solves the pre-built algebraic model using HiGHS solver.\n        The model is built during optimization from the energy system configuration.\n\n        Returns:\n            OptimizationResults containing the solution and metadata.\n\n        \"\"\"\n        model_builder = EnergyAlgebraicModelBuilder(\n            energy_system_parameters=self._validated_model.energy_system_parameters,\n        )\n        milp_model = model_builder.build()\n        return optimize_algebraic_model(milp_model)\n</code></pre>"},{"location":"api/energy_system/#odys.energy_system.EnergySystem.__init__","title":"<code>__init__(portfolio, timestep, number_of_steps, power_unit, scenarios, markets=None)</code>","text":"<p>Initialize the energy system configuration and optimizer.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>AssetPortfolio</code> <p>The portfolio of energy assets (generators, batteries, etc.).</p> required <code>timestep</code> <code>timedelta</code> <p>Duration of each time period.</p> required <code>number_of_steps</code> <code>int</code> <p>Number of time steps.</p> required <code>power_unit</code> <code>str</code> <p>Unit used for power quantities ('W', 'kW', or 'MW').</p> required <code>scenarios</code> <code>Scenario | Sequence[StochasticScenario]</code> <p>Sequence of stochastic scenarios. Probabilities must add up to 1.</p> required <code>markets</code> <code>EnergyMarket | Sequence[EnergyMarket] | None</code> <p>Optional energy markets in which assets can participate.</p> <code>None</code> Source code in <code>src/odys/energy_system.py</code> <pre><code>def __init__(  # noqa: PLR0913\n    self,\n    portfolio: AssetPortfolio,\n    timestep: timedelta,\n    number_of_steps: int,\n    power_unit: str,\n    scenarios: Scenario | Sequence[StochasticScenario],\n    markets: EnergyMarket | Sequence[EnergyMarket] | None = None,\n) -&gt; None:\n    \"\"\"Initialize the energy system configuration and optimizer.\n\n    Args:\n        portfolio: The portfolio of energy assets (generators, batteries, etc.).\n        timestep: Duration of each time period.\n        number_of_steps: Number of time steps.\n        power_unit: Unit used for power quantities ('W', 'kW', or 'MW').\n        scenarios: Sequence of stochastic scenarios. Probabilities must add up to 1.\n        markets: Optional energy markets in which assets can participate.\n\n    \"\"\"\n    self._validated_model = ValidatedEnergySystem(\n        portfolio=portfolio,\n        markets=markets,\n        timestep=timestep,\n        number_of_steps=number_of_steps,\n        power_unit=power_unit,  # ty: ignore  # pyright: ignore[reportArgumentType]\n        scenarios=scenarios,\n    )\n</code></pre>"},{"location":"api/energy_system/#odys.energy_system.EnergySystem.optimize","title":"<code>optimize()</code>","text":"<p>Optimize the energy system.</p> <p>This method solves the pre-built algebraic model using HiGHS solver. The model is built during optimization from the energy system configuration.</p> <p>Returns:</p> Type Description <code>OptimizationResults</code> <p>OptimizationResults containing the solution and metadata.</p> Source code in <code>src/odys/energy_system.py</code> <pre><code>def optimize(self) -&gt; OptimizationResults:\n    \"\"\"Optimize the energy system.\n\n    This method solves the pre-built algebraic model using HiGHS solver.\n    The model is built during optimization from the energy system configuration.\n\n    Returns:\n        OptimizationResults containing the solution and metadata.\n\n    \"\"\"\n    model_builder = EnergyAlgebraicModelBuilder(\n        energy_system_parameters=self._validated_model.energy_system_parameters,\n    )\n    milp_model = model_builder.build()\n    return optimize_algebraic_model(milp_model)\n</code></pre>"},{"location":"api/energy_system/#scenarios","title":"Scenarios","text":"<p>Scenario definitions for energy system optimization models.</p>"},{"location":"api/energy_system/#odys.energy_system_models.scenarios.Scenario","title":"<code>Scenario</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Scenario conditions.</p> Source code in <code>src/odys/energy_system_models/scenarios.py</code> <pre><code>class Scenario(BaseModel):\n    \"\"\"Scenario conditions.\"\"\"\n\n    model_config = ConfigDict(strict=True)\n\n    available_capacity_profiles: Mapping[str, Sequence[float]] | None = Field(\n        default=None,\n        description=\"Available capacity for each asset.\",\n    )\n    load_profiles: Mapping[str, Sequence[float]] | None = Field(default=None, description=\"Load profiles\")\n    market_prices: Mapping[str, Sequence[float]] | None = Field(default=None, description=\"Market prices.\")\n</code></pre>"},{"location":"api/energy_system/#odys.energy_system_models.scenarios.StochasticScenario","title":"<code>StochasticScenario</code>","text":"<p>               Bases: <code>Scenario</code></p> <p>Stochastic scenario conditions.</p> Source code in <code>src/odys/energy_system_models/scenarios.py</code> <pre><code>class StochasticScenario(Scenario):\n    \"\"\"Stochastic scenario conditions.\"\"\"\n\n    name: str\n    probability: float = Field(ge=0, le=1, description=\"Probability (0-1) of the scenario.\")\n</code></pre>"},{"location":"api/energy_system/#odys.energy_system_models.scenarios.validate_sequence_of_stochastic_scenarios","title":"<code>validate_sequence_of_stochastic_scenarios(scenarios)</code>","text":"<p>Validate that scenarios probabilities add up to 1.</p> <p>Parameters:</p> Name Type Description Default <code>scenarios</code> <code>Sequence[StochasticScenario]</code> <p>Sequence of scenarios.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If sum of probabilities is different than 1.</p> Source code in <code>src/odys/energy_system_models/scenarios.py</code> <pre><code>def validate_sequence_of_stochastic_scenarios(\n    scenarios: Sequence[StochasticScenario],\n) -&gt; None:\n    \"\"\"Validate that scenarios probabilities add up to 1.\n\n    Args:\n        scenarios: Sequence of scenarios.\n\n    Raises:\n        ValueError: If sum of probabilities is different than 1.\n    \"\"\"\n    sum_of_probabilities = sum(scenario.probability for scenario in scenarios)\n    if sum_of_probabilities != 1.0:\n        msg = f\"Scenarios should add up to 1, but got sum = {sum_of_probabilities} instead.\"\n        raise ValueError(msg)\n\n    scenario_names = [scenario.name for scenario in scenarios]\n    duplicated_scenario_names = {scenario for scenario in scenario_names if scenario_names.count(scenario) &gt; 1}\n    if duplicated_scenario_names:\n        msg = (\n            f\"Scenarios must have a unique name. The following names appear more than once: {duplicated_scenario_names}\"\n        )\n        raise ValueError(msg)\n</code></pre>"},{"location":"api/energy_system/#assets","title":"Assets","text":""},{"location":"api/energy_system/#base-asset","title":"Base Asset","text":"<p>Base classes for energy system assets.</p> <p>This module defines the base classes and interfaces for energy system assets including the EnergyAsset abstract base class.</p>"},{"location":"api/energy_system/#odys.energy_system_models.assets.base.EnergyAsset","title":"<code>EnergyAsset</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>ABC</code></p> <p>Base class for all energy system assets.</p> <p>This abstract class defines the common interface for energy assets like generators, batteries, and other energy system components.</p> Source code in <code>src/odys/energy_system_models/assets/base.py</code> <pre><code>class EnergyAsset(BaseModel, ABC):  # pyright: ignore[reportUnsafeMultipleInheritance]\n    \"\"\"Base class for all energy system assets.\n\n    This abstract class defines the common interface for energy assets\n    like generators, batteries, and other energy system components.\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    name: str\n</code></pre>"},{"location":"api/energy_system/#powergenerator","title":"PowerGenerator","text":"<p>Power generator asset implementation.</p> <p>This module provides the PowerGenerator class for modeling electrical generators in energy system optimization problems.</p>"},{"location":"api/energy_system/#odys.energy_system_models.assets.generator.PowerGenerator","title":"<code>PowerGenerator</code>","text":"<p>               Bases: <code>EnergyAsset</code></p> <p>Represents a power generator in the energy system.</p> <p>This class models generators with various operational constraints including nominal power, variable costs, ramp rates, and startup/shutdown costs.</p> Source code in <code>src/odys/energy_system_models/assets/generator.py</code> <pre><code>class PowerGenerator(EnergyAsset):\n    \"\"\"Represents a power generator in the energy system.\n\n    This class models generators with various operational constraints\n    including nominal power, variable costs, ramp rates, and startup/shutdown costs.\n    \"\"\"\n\n    nominal_power: float = Field(\n        strict=True,\n        gt=0,\n        description=\"Nominal power of the generator in MW.\",\n    )\n\n    variable_cost: float = Field(\n        strict=True,\n        gt=0,\n        description=\"Variable cost of the generator in currency per MWh.\",\n    )\n\n    ramp_up: float | None = Field(\n        default=None,\n        strict=True,\n        ge=0,\n        description=\"Ramp-up rate of the generator in MW per hour\",\n    )\n\n    ramp_down: float | None = Field(\n        default=None,\n        strict=True,\n        ge=0,\n        description=\"Ramp-down rate of the generator in MW per hour\",\n    )\n\n    min_up_time: int = Field(\n        default=1,\n        strict=True,\n        ge=1,\n        description=\"Minimum up time\",\n    )\n\n    min_down_time: int = Field(\n        default=1,\n        strict=True,\n        ge=1,\n        description=\"Minimum down time\",\n    )\n\n    min_power: float = Field(\n        default=0.0,\n        strict=True,\n        ge=0,\n        description=\"Minimum power output\",\n    )\n\n    startup_cost: float = Field(\n        default=0.0,\n        strict=True,\n        ge=0,\n        description=\"Startup cost of the generator, in currency per MWh.\",\n    )\n\n    shutdown_cost: float | None = Field(\n        default=None,\n        strict=True,\n        ge=0,\n        description=\"Shutdown cost of the generator, in currency per MWh\",\n    )\n</code></pre>"},{"location":"api/energy_system/#battery","title":"Battery","text":"<p>Energy storage asset implementation.</p> <p>This module provides the Battery class for modeling energy storage devices in energy system optimization problems.</p>"},{"location":"api/energy_system/#odys.energy_system_models.assets.storage.Battery","title":"<code>Battery</code>","text":"<p>               Bases: <code>EnergyAsset</code></p> <p>Represents a battery storage system in the energy system.</p> <p>This class models batteries with various operational constraints including capacity, power limits, efficiency, state of charge, and degradation characteristics.</p> Source code in <code>src/odys/energy_system_models/assets/storage.py</code> <pre><code>class Battery(EnergyAsset):\n    \"\"\"Represents a battery storage system in the energy system.\n\n    This class models batteries with various operational constraints\n    including capacity, power limits, efficiency, state of charge,\n    and degradation characteristics.\n    \"\"\"\n\n    capacity: float = Field(\n        strict=True,\n        gt=0,\n        description=\"Battery capacity in MWh.\",\n    )\n    max_power: float = Field(\n        strict=True,\n        gt=0,\n        description=\"Maximum power in MW.\",\n    )\n    efficiency_charging: float = Field(\n        strict=True,\n        gt=0,\n        le=1,\n        description=\"Charging efficiency (0-1).\",\n    )\n    efficiency_discharging: float = Field(\n        strict=True,\n        gt=0,\n        le=1,\n        description=\"Discharging efficiency (0-1).\",\n    )\n    soc_start: float = Field(\n        strict=True,\n        ge=0,\n        le=1,\n        description=\"Initial state of charge as a fraction of capacity (0-1).\",\n    )\n    soc_end: float | None = Field(\n        default=None,\n        strict=True,\n        ge=0,\n        le=1,\n        description=\"Final state of charge as a fraction of capacity (0-1).\",\n    )\n    soc_min: float = Field(\n        default=0,\n        strict=True,\n        ge=0,\n        le=1,\n        description=\"Minimum state of charge as a fraction of capacity (0-1).\",\n    )\n    soc_max: float = Field(\n        default=1,\n        strict=True,\n        ge=0,\n        le=1,\n        description=\"Maximum state of charge as a fraction of capacity (0-1).\",\n    )\n    degradation_cost: float | None = Field(\n        default=None,\n        strict=True,\n        ge=0,\n        description=\"Degradation cost, in currency per MWh cycled.\",\n    )\n    self_discharge_rate: float | None = Field(\n        default=None,\n        strict=True,\n        ge=0,\n        le=1,\n        description=\"Self-discharge rate (0-1) per hour.\",\n    )\n\n    @model_validator(mode=\"after\")\n    def _validate_soc_start_and_terminal(self) -&gt; Self:\n        for name in (\"soc_start\", \"soc_end\"):\n            battery_soc = getattr(self, name)\n            if battery_soc is None:\n                continue\n\n            if battery_soc &lt; self.soc_min:\n                msg = f\"{name} ({battery_soc}) must be \u2265 soc_min ({self.soc_min}).\"\n                raise ValueError(msg)\n            if battery_soc &gt; self.soc_max:\n                msg = f\"{name} ({battery_soc}) must be \u2264 soc_max ({self.soc_max}).\"\n                raise ValueError(msg)\n\n        return self\n\n    @model_validator(mode=\"after\")\n    def _validate_soc_min_less_than_max(self) -&gt; Self:\n        if self.soc_min &gt;= self.soc_max:\n            msg = f\"soc_min ({self.soc_min}) must be &lt; soc_max ({self.soc_max}).\"\n            raise ValueError(msg)\n        return self\n</code></pre>"},{"location":"api/energy_system/#load","title":"Load","text":"<p>Load asset definitions for energy system models.</p>"},{"location":"api/energy_system/#odys.energy_system_models.assets.load.Load","title":"<code>Load</code>","text":"<p>               Bases: <code>EnergyAsset</code></p> <p>Represents a load asset in the energy system.</p> Source code in <code>src/odys/energy_system_models/assets/load.py</code> <pre><code>class Load(EnergyAsset):\n    \"\"\"Represents a load asset in the energy system.\"\"\"\n\n    type: LoadType = Field(\n        default=LoadType.Fixed,\n        strict=True,\n        description=\"Type of load\",\n    )\n\n    variable_cost_to_increase: float | None = Field(\n        default=None,\n        strict=True,\n        description=\"Variable cost of changing the load currency per MWh.\",\n    )\n\n    variable_cost_to_decrease: float | None = Field(\n        default=None,\n        strict=True,\n        description=\"Variable cost of changing the load currency per MWh.\",\n    )\n\n    @model_validator(mode=\"after\")\n    def _validate_type_and_variable_cost(self) -&gt; Self:\n        if self.type == LoadType.Fixed and (self.variable_cost_to_decrease or self.variable_cost_to_increase):\n            msg = \"`variable_cost_to_decrease` and `variable_cost_to_incrase` are fields valid only for Flexible loads.\"\n            raise ValueError(msg)\n        if self.type == LoadType.Flexible and not (self.variable_cost_to_decrease and self.variable_cost_to_increase):\n            msg = \"`variable_cost_to_decrease` and `variable_cost_to_incrase` must be specified for Flexible load\"\n            raise ValueError(msg)\n        return self\n</code></pre>"},{"location":"api/energy_system/#odys.energy_system_models.assets.load.LoadType","title":"<code>LoadType</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Load type enumeration.</p> Source code in <code>src/odys/energy_system_models/assets/load.py</code> <pre><code>class LoadType(StrEnum):\n    \"\"\"Load type enumeration.\"\"\"\n\n    Fixed = \"fixed\"\n    Flexible = \"flexible\"\n</code></pre>"},{"location":"api/energy_system/#assetportfolio","title":"AssetPortfolio","text":"<p>Asset portfolio management for energy systems.</p> <p>This module provides the AssetPortfolio class for managing collections of energy system assets including generators, batteries, and other components.</p>"},{"location":"api/energy_system/#odys.energy_system_models.assets.portfolio.AssetPortfolio","title":"<code>AssetPortfolio</code>","text":"<p>A collection of energy system assets.</p> <p>This class manages a portfolio of energy assets including generators, batteries, and other energy system components. It provides methods to add, retrieve, and filter assets by type.</p> Source code in <code>src/odys/energy_system_models/assets/portfolio.py</code> <pre><code>class AssetPortfolio:\n    \"\"\"A collection of energy system assets.\n\n    This class manages a portfolio of energy assets including generators,\n    batteries, and other energy system components. It provides methods\n    to add, retrieve, and filter assets by type.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize an empty asset portfolio.\"\"\"\n        self._assets: dict[str, EnergyAsset] = {}\n\n    def add_asset(self, asset: EnergyAsset) -&gt; None:\n        \"\"\"Add an energy asset to the portfolio.\n\n        Args:\n            asset: The energy asset to add to the portfolio.\n\n        Raises:\n            ValueError: If an asset with the same name already exists.\n            TypeError: If the asset is not an instance of EnergyAsset.\n\n        \"\"\"\n        if asset.name in self._assets:\n            msg = f\"Asset with name '{asset.name}' already exists.\"\n            raise ValueError(msg)\n        self._assets[asset.name] = asset\n\n    def get_asset(self, name: str) -&gt; EnergyAsset:\n        \"\"\"Retrieve an asset from the portfolio by name.\n\n        Args:\n            name: The name of the asset to retrieve.\n\n        Returns:\n            The energy asset with the specified name.\n\n        Raises:\n            KeyError: If no asset with the specified name exists.\n\n        \"\"\"\n        if name not in self._assets:\n            msg = f\"Asset with name '{name}' does not exist.\"\n            raise KeyError(msg)\n        return self._assets[name]\n\n    def _get_assets_by_type(self, asset_type: type[T]) -&gt; tuple[T, ...]:\n        return tuple(asset for asset in self._assets.values() if isinstance(asset, asset_type))\n\n    @property\n    def assets(self) -&gt; MappingProxyType[str, EnergyAsset]:\n        \"\"\"Get a read-only view of all assets in the portfolio.\n\n        Returns:\n            A mapping proxy containing all assets indexed by name.\n\n        \"\"\"\n        return MappingProxyType(self._assets)\n\n    @property\n    def generators(self) -&gt; tuple[PowerGenerator, ...]:\n        \"\"\"Get all power generators in the portfolio.\n\n        Returns:\n            A tuple containing all PowerGenerator assets.\n\n        \"\"\"\n        return self._get_assets_by_type(PowerGenerator)\n\n    @property\n    def batteries(self) -&gt; tuple[Battery, ...]:\n        \"\"\"Get all batteries in the portfolio.\n\n        Returns:\n            A tuple containing all Battery assets.\n\n        \"\"\"\n        return self._get_assets_by_type(Battery)\n\n    @property\n    def loads(self) -&gt; tuple[Load, ...]:\n        \"\"\"Get all the loads in the portfolio.\n\n        Returns:\n            A tuple containing all Load assets.\n\n        \"\"\"\n        return self._get_assets_by_type(Load)\n</code></pre>"},{"location":"api/energy_system/#odys.energy_system_models.assets.portfolio.AssetPortfolio.assets","title":"<code>assets</code>  <code>property</code>","text":"<p>Get a read-only view of all assets in the portfolio.</p> <p>Returns:</p> Type Description <code>MappingProxyType[str, EnergyAsset]</code> <p>A mapping proxy containing all assets indexed by name.</p>"},{"location":"api/energy_system/#odys.energy_system_models.assets.portfolio.AssetPortfolio.batteries","title":"<code>batteries</code>  <code>property</code>","text":"<p>Get all batteries in the portfolio.</p> <p>Returns:</p> Type Description <code>tuple[Battery, ...]</code> <p>A tuple containing all Battery assets.</p>"},{"location":"api/energy_system/#odys.energy_system_models.assets.portfolio.AssetPortfolio.generators","title":"<code>generators</code>  <code>property</code>","text":"<p>Get all power generators in the portfolio.</p> <p>Returns:</p> Type Description <code>tuple[PowerGenerator, ...]</code> <p>A tuple containing all PowerGenerator assets.</p>"},{"location":"api/energy_system/#odys.energy_system_models.assets.portfolio.AssetPortfolio.loads","title":"<code>loads</code>  <code>property</code>","text":"<p>Get all the loads in the portfolio.</p> <p>Returns:</p> Type Description <code>tuple[Load, ...]</code> <p>A tuple containing all Load assets.</p>"},{"location":"api/energy_system/#odys.energy_system_models.assets.portfolio.AssetPortfolio.__init__","title":"<code>__init__()</code>","text":"<p>Initialize an empty asset portfolio.</p> Source code in <code>src/odys/energy_system_models/assets/portfolio.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize an empty asset portfolio.\"\"\"\n    self._assets: dict[str, EnergyAsset] = {}\n</code></pre>"},{"location":"api/energy_system/#odys.energy_system_models.assets.portfolio.AssetPortfolio.add_asset","title":"<code>add_asset(asset)</code>","text":"<p>Add an energy asset to the portfolio.</p> <p>Parameters:</p> Name Type Description Default <code>asset</code> <code>EnergyAsset</code> <p>The energy asset to add to the portfolio.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an asset with the same name already exists.</p> <code>TypeError</code> <p>If the asset is not an instance of EnergyAsset.</p> Source code in <code>src/odys/energy_system_models/assets/portfolio.py</code> <pre><code>def add_asset(self, asset: EnergyAsset) -&gt; None:\n    \"\"\"Add an energy asset to the portfolio.\n\n    Args:\n        asset: The energy asset to add to the portfolio.\n\n    Raises:\n        ValueError: If an asset with the same name already exists.\n        TypeError: If the asset is not an instance of EnergyAsset.\n\n    \"\"\"\n    if asset.name in self._assets:\n        msg = f\"Asset with name '{asset.name}' already exists.\"\n        raise ValueError(msg)\n    self._assets[asset.name] = asset\n</code></pre>"},{"location":"api/energy_system/#odys.energy_system_models.assets.portfolio.AssetPortfolio.get_asset","title":"<code>get_asset(name)</code>","text":"<p>Retrieve an asset from the portfolio by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the asset to retrieve.</p> required <p>Returns:</p> Type Description <code>EnergyAsset</code> <p>The energy asset with the specified name.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no asset with the specified name exists.</p> Source code in <code>src/odys/energy_system_models/assets/portfolio.py</code> <pre><code>def get_asset(self, name: str) -&gt; EnergyAsset:\n    \"\"\"Retrieve an asset from the portfolio by name.\n\n    Args:\n        name: The name of the asset to retrieve.\n\n    Returns:\n        The energy asset with the specified name.\n\n    Raises:\n        KeyError: If no asset with the specified name exists.\n\n    \"\"\"\n    if name not in self._assets:\n        msg = f\"Asset with name '{name}' does not exist.\"\n        raise KeyError(msg)\n    return self._assets[name]\n</code></pre>"},{"location":"api/energy_system/#markets","title":"Markets","text":"<p>Energy market definitions for energy system models.</p>"},{"location":"api/energy_system/#odys.energy_system_models.markets.EnergyMarket","title":"<code>EnergyMarket</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an energy market in the energy system.</p> Source code in <code>src/odys/energy_system_models/markets.py</code> <pre><code>class EnergyMarket(BaseModel):\n    \"\"\"Represents an energy market in the energy system.\"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\")\n\n    name: str\n    max_trading_volume_per_step: float = Field(gt=0)\n    trade_direction: TradeDirection = TradeDirection.BOTH\n    stage_fixed: bool = Field(\n        default=False,\n        description=\"If true, the associated variables are fixed across scenarios.\",\n    )\n</code></pre>"},{"location":"api/energy_system/#odys.energy_system_models.markets.TradeDirection","title":"<code>TradeDirection</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Direction of the market positions.</p> Source code in <code>src/odys/energy_system_models/markets.py</code> <pre><code>class TradeDirection(StrEnum):\n    \"\"\"Direction of the market positions.\"\"\"\n\n    BUY = \"buy\"\n    SELL = \"sell\"\n    BOTH = \"both\"\n</code></pre>"},{"location":"api/energy_system/#validated-energy-system","title":"Validated Energy System","text":"<p>Validated energy system configuration.</p> <p>This module provides the ValidatedEnergySystem class which validates and transforms user-provided energy system configurations into parameters suitable for the optimization model.</p>"},{"location":"api/energy_system/#odys.energy_system_models.validated_energy_system.ValidatedEnergySystem","title":"<code>ValidatedEnergySystem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the complete energy system configuration with validation.</p> <p>This class defines the energy system including the asset portfolio, demand profile, time discretization, and available capacity profiles. It performs comprehensive validation to ensure the system is feasible:</p> <ul> <li>Validates that capacity profile lengths match demand profile length</li> <li>Ensures available capacity profiles are only specified for generators</li> <li>Verifies that maximum available power can meet peak demand</li> <li>Checks that total energy capacity can meet total energy demand</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the system configuration is infeasible.</p> <code>TypeError</code> <p>If available capacity is specified for non-generator assets.</p> Source code in <code>src/odys/energy_system_models/validated_energy_system.py</code> <pre><code>class ValidatedEnergySystem(BaseModel):\n    \"\"\"Represents the complete energy system configuration with validation.\n\n    This class defines the energy system including the asset portfolio,\n    demand profile, time discretization, and available capacity profiles.\n    It performs comprehensive validation to ensure the system is feasible:\n\n    - Validates that capacity profile lengths match demand profile length\n    - Ensures available capacity profiles are only specified for generators\n    - Verifies that maximum available power can meet peak demand\n    - Checks that total energy capacity can meet total energy demand\n\n    Raises:\n        ValueError: If the system configuration is infeasible.\n        TypeError: If available capacity is specified for non-generator assets.\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True, arbitrary_types_allowed=True, extra=\"forbid\")\n\n    portfolio: AssetPortfolio\n    timestep: timedelta\n    number_of_steps: int\n    power_unit: PowerUnit\n    markets: EnergyMarket | Sequence[EnergyMarket] | None = Field(default=None, init_var=True)\n    scenarios: Scenario | Sequence[StochasticScenario] = Field(init_var=True)\n\n    @field_validator(\"scenarios\", mode=\"after\")\n    @staticmethod\n    def _validated_scenario_sequence(\n        value: Scenario | list[StochasticScenario],\n    ) -&gt; Scenario | list[StochasticScenario]:\n        if isinstance(value, list):\n            validate_sequence_of_stochastic_scenarios(value)\n\n        return value\n\n    @cached_property\n    def _collection_of_scenarios(self) -&gt; tuple[StochasticScenario, ...]:\n        if isinstance(self.scenarios, Scenario):\n            return (\n                StochasticScenario(\n                    name=\"deterministic_scenario\",\n                    probability=1.0,\n                    available_capacity_profiles=self.scenarios.available_capacity_profiles,\n                    load_profiles=self.scenarios.load_profiles,\n                    market_prices=self.scenarios.market_prices,\n                ),\n            )\n\n        return tuple(self.scenarios)\n\n    @cached_property\n    def _collection_of_markets(self) -&gt; tuple[EnergyMarket, ...]:\n        if not self.markets:\n            return ()\n        if isinstance(self.markets, EnergyMarket):\n            return (self.markets,)\n\n        return tuple(self.markets)\n\n    @cached_property\n    def energy_system_parameters(self) -&gt; EnergySystemParameters:\n        \"\"\"Parameters of the energy system.\"\"\"\n        return EnergySystemParameters(\n            generators=self._generator_parameters,\n            batteries=self._battery_parameters,\n            loads=self._load_parameters,\n            markets=self._market_parameters,\n            scenarios=self._scenario_parameters,\n        )\n\n    @cached_property\n    def _scenario_parameters(self) -&gt; ScenarioParameters:\n        generators_index = self._generator_parameters.index if self._generator_parameters else None\n        batteries_index = self._battery_parameters.index if self._battery_parameters else None\n        loads_index = self._load_parameters.index if self._load_parameters else None\n        markets_index = self._market_parameters.index if self._market_parameters else None\n\n        return ScenarioParameters(\n            number_of_timesteps=self.number_of_steps,\n            scenarios=self._collection_of_scenarios,\n            generators_index=generators_index,\n            batteries_index=batteries_index,\n            loads_index=loads_index,\n            markets_index=markets_index,\n        )\n\n    @property\n    def _generator_parameters(self) -&gt; GeneratorParameters | None:\n        if len(self.portfolio.generators) == 0:\n            return None\n        return GeneratorParameters(generators=self.portfolio.generators)\n\n    @property\n    def _battery_parameters(self) -&gt; BatteryParameters | None:\n        if len(self.portfolio.batteries) == 0:\n            return None\n        return BatteryParameters(self.portfolio.batteries)\n\n    @property\n    def _load_parameters(self) -&gt; LoadParameters | None:\n        if len(self.portfolio.loads) == 0:\n            return None\n        return LoadParameters(loads=self.portfolio.loads)\n\n    @property\n    def _market_parameters(self) -&gt; MarketParameters | None:\n        if self.markets is None:\n            return None\n        return MarketParameters(self._collection_of_markets)\n\n    @model_validator(mode=\"after\")\n    def _validate_inputs(self) -&gt; Self:\n        self._validate_load_consistent_with_scenario_load_profiles()\n        self._validate_markets_consistent_with_scenario_market_prices()\n\n        for scenario in self._collection_of_scenarios:\n            self._validate_available_capacity_scenario(scenario)\n            self._validate_load_profiles(scenario)\n\n            if not self.markets:\n                self._validate_enough_power_to_meet_demand(scenario)\n                self._validate_enough_energy_to_meet_demand(scenario)\n\n        return self\n\n    def _validate_load_consistent_with_scenario_load_profiles(self) -&gt; None:\n        \"\"\"Validate consistency between portfolio loads and scenario load profiles.\n\n        If there are loads in the portfolio, each scenario must have a profile for each load.\n        If there are no loads in the portfolio, all scenarios should have load_profiles=None.\n\n        Raises:\n            ValueError: If load profiles are inconsistent with portfolio loads.\n        \"\"\"\n        has_loads = bool(self.portfolio.loads)\n\n        for scenario in self._collection_of_scenarios:\n            if has_loads:\n                if scenario.load_profiles is None:\n                    msg = (\n                        f\"Portfolio contains loads {[load.name for load in self.portfolio.loads]}, \"\n                        f\"but scenario '{scenario.name}' has no load profiles.\"\n                    )\n                    raise ValueError(msg)\n\n                portfolio_load_names = {load.name for load in self.portfolio.loads}\n                scenario_load_names = set(scenario.load_profiles.keys())\n\n                missing_loads = portfolio_load_names - scenario_load_names\n                if missing_loads:\n                    msg = f\"Scenario '{scenario.name}' is missing load profiles for: {sorted(missing_loads)}\"\n                    raise ValueError(msg)\n\n                extra_loads = scenario_load_names - portfolio_load_names\n                if extra_loads:\n                    msg = (\n                        f\"Scenario '{scenario.name}' has load profiles for loads not in portfolio: \"\n                        f\"{sorted(extra_loads)}\"\n                    )\n                    raise ValueError(msg)\n            elif scenario.load_profiles is not None:\n                msg = (\n                    f\"Portfolio contains no loads, but scenario '{scenario.name}' \"\n                    f\"has load profiles: {list(scenario.load_profiles.keys())}\"\n                )\n                raise ValueError(msg)\n\n    def _validate_markets_consistent_with_scenario_market_prices(self) -&gt; None:\n        \"\"\"Validate consistency between portfolio markets and scenario market prices.\n\n        If there are markets in the portfolio, each scenario must have prices for each market.\n        If there are no markets in the portfolio, all scenarios should have market_prices=None.\n\n        Raises:\n            ValueError: If market prices are inconsistent with portfolio markets.\n        \"\"\"\n        has_markets = bool(self._collection_of_markets)\n\n        for scenario in self._collection_of_scenarios:\n            if has_markets:\n                if scenario.market_prices is None:\n                    msg = (\n                        f\"Portfolio contains markets {[market.name for market in self._collection_of_markets]}, \"\n                        f\"but scenario '{scenario.name}' has no market prices.\"\n                    )\n                    raise ValueError(msg)\n\n                portfolio_market_names = {market.name for market in self._collection_of_markets}\n                scenario_market_names = set(scenario.market_prices.keys())\n\n                missing_markets = portfolio_market_names - scenario_market_names\n                if missing_markets:\n                    msg = f\"Scenario '{scenario.name}' is missing market prices for: {sorted(missing_markets)}\"\n                    raise ValueError(msg)\n\n                extra_markets = scenario_market_names - portfolio_market_names\n                if extra_markets:\n                    msg = (\n                        f\"Scenario '{scenario.name}' has market prices for markets not in portfolio: \"\n                        f\"{sorted(extra_markets)}\"\n                    )\n                    raise ValueError(msg)\n            elif scenario.market_prices is not None:\n                msg = (\n                    f\"Portfolio contains no markets, but scenario '{scenario.name}' \"\n                    f\"has market prices: {list(scenario.market_prices.keys())}\"\n                )\n                raise ValueError(msg)\n\n    def _validate_load_profiles(self, scenario: Scenario) -&gt; None:\n        \"\"\"Validate that load profile lengths match the number of time steps.\n\n        Raises:\n            ValueError: If a load profile length doesn't match the number of time steps.\n\n        \"\"\"\n        if scenario.load_profiles is None:\n            return\n\n        for load_name, load_profile in scenario.load_profiles.items():\n            if len(load_profile) != self.number_of_steps:\n                msg = (\n                    f\"Length of load profile {load_name} ({len(load_profile)})\"\n                    f\" does not match the number of time steps ({self.number_of_steps}).\"\n                )\n                raise ValueError(msg)\n\n    def _validate_available_capacity_scenario(self, scenario: Scenario) -&gt; None:\n        \"\"\"Validate that available capacity profiles are only for generators.\n\n        Raises:\n            TypeError: If available capacity is specified for non-generator assets.\n            ValueError: If capacity profile length doesn't match demand profile.\n\n        \"\"\"\n        if scenario.available_capacity_profiles is None:\n            return\n\n        for asset_name, capacity_profile in scenario.available_capacity_profiles.items():\n            asset = self.portfolio.get_asset(asset_name)\n            if not isinstance(asset, PowerGenerator):\n                msg = (\n                    \"Available capacity can only be specified for generators, \"\n                    f\"but got '{asset_name}' of type {type(asset)}.\"\n                )\n                raise TypeError(msg)\n            if len(capacity_profile) != self.number_of_steps:\n                msg = (\n                    f\"Length of capacity profile for {asset_name} ({len(capacity_profile)})\"\n                    f\" does not match the number of time steps ({self.number_of_steps}).\"\n                )\n                raise ValueError(msg)\n            for capacity_i in capacity_profile:\n                if not (0 &lt;= capacity_i &lt;= asset.nominal_power):\n                    msg = (\n                        f\"Available capacity value {capacity_i} for asset '{asset_name}' is invalid. \"\n                        f\"Values must be between 0 and the asset's nominal power ({asset.nominal_power}).\"\n                    )\n                    raise ValueError(msg)\n\n    def _validate_enough_power_to_meet_demand(self, scenario: StochasticScenario) -&gt; None:\n        \"\"\"Validate that maximum available power can meet peak demand.\n\n        This method checks that the sum of generator nominal power and\n        battery capacity can meet the maximum demand at any time period.\n\n        Raises:\n            ValueError: If maximum available power is insufficient for peak demand.\n\n        \"\"\"\n        if scenario.load_profiles is None:\n            msg = \"Load profile is empty, there is nothing to balance.\"\n            raise ValueError(msg)\n\n        cumulative_generators_power = sum(gen.nominal_power for gen in self.portfolio.generators)\n        # TODO: We assume full capacity can be discharged -&gt; Needs to be limited by max power\n        cumulative_battery_capacities = sum(bat.capacity for bat in self.portfolio.batteries)\n        max_available_power = cumulative_generators_power + cumulative_battery_capacities\n\n        for load_name, load_profile in scenario.load_profiles.items():\n            for t, demand_t in enumerate(load_profile):\n                if max_available_power &lt; demand_t:\n                    msg = (\n                        f\"Infeasible problem in scenario '{scenario.name}' for load '{load_name}' at time index {t}: \"\n                        f\"Demand = {demand_t}, but maximum available generation + battery = {max_available_power}.\"\n                    )\n                    raise ValueError(msg)\n\n    def _validate_enough_energy_to_meet_demand(self, scenario: StochasticScenario) -&gt; None:  # noqa: ARG002\n        \"\"\"Validate that the system has enough energy to meet total demand.\n\n        This method checks that the total energy available from generators\n        and batteries can meet the total energy demand over the time horizon.\n\n        \"\"\"\n        # TODO: Validate that:\n        # sum(demand * timestep) &lt;= sum(generator.nominal_power * timestep) + sum(battery.soc_initial - battery.soc_terminal) # noqa: ERA001, E501\n        return\n</code></pre>"},{"location":"api/energy_system/#odys.energy_system_models.validated_energy_system.ValidatedEnergySystem.energy_system_parameters","title":"<code>energy_system_parameters</code>  <code>cached</code> <code>property</code>","text":"<p>Parameters of the energy system.</p>"},{"location":"api/math_model/","title":"Math Model API","text":"<p>The <code>math_model</code> module contains the internals for building and solving the mixed-integer linear program (MILP) that powers the optimization.</p>"},{"location":"api/math_model/#model-builder","title":"Model Builder","text":"<p>Builder for constructing linopy optimization models from energy system parameters.</p> <p>This module provides the EnergyAlgebraicModelBuilder that assembles variables, constraints, and objectives into a solvable MILP model.</p>"},{"location":"api/math_model/#odys.math_model.model_builder.EnergyAlgebraicModelBuilder","title":"<code>EnergyAlgebraicModelBuilder</code>","text":"<p>Builder class for constructing algebraic energy system optimization models.</p> <p>This class takes a validated energy system configuration and builds a complete linopy optimization model including variables, constraints, and objectives ready for solving.</p> <p>The builder ensures the model is constructed only once and prevents multiple builds of the same instance.</p> Source code in <code>src/odys/math_model/model_builder.py</code> <pre><code>class EnergyAlgebraicModelBuilder:\n    \"\"\"Builder class for constructing algebraic energy system optimization models.\n\n    This class takes a validated energy system configuration and builds\n    a complete linopy optimization model including variables, constraints,\n    and objectives ready for solving.\n\n    The builder ensures the model is constructed only once and prevents\n    multiple builds of the same instance.\n    \"\"\"\n\n    def __init__(\n        self,\n        energy_system_parameters: EnergySystemParameters,\n    ) -&gt; None:\n        \"\"\"Initialize the model builder with validated energy system.\n\n        Args:\n            energy_system_parameters: Parameters of the energy system,\n                containing all assets, demand profiles, and constraints.\n        \"\"\"\n        self._milp_model = EnergyMILPModel(energy_system_parameters)\n        self._model_is_built: bool = False\n\n    def build(self) -&gt; EnergyMILPModel:\n        \"\"\"Build the complete optimization model with variables, constraints, and objective.\n\n        Returns:\n            The fully constructed EnergyMILPModel ready for solving.\n\n        Raises:\n            AttributeError: If the model has already been built.\n\n        \"\"\"\n        if self._model_is_built:\n            msg = \"Model has already been built.\"\n            raise AttributeError(msg)\n        self._add_model_variables()\n        self._add_model_constraints()\n        self._add_model_objective()\n        self._model_is_built = True\n\n        return self._milp_model\n\n    def _add_model_variables(self) -&gt; None:\n        variables_to_add = []\n        if self._milp_model.parameters.generators:\n            variables_to_add.extend(GENERATOR_VARIABLES)\n\n        if self._milp_model.parameters.batteries:\n            variables_to_add.extend(BATTERY_VARIABLES)\n\n        if self._milp_model.parameters.markets:\n            variables_to_add.extend(MARKET_VARIABLES)\n\n        for variable in variables_to_add:\n            linopy_variable = self._get_linopy_variable_params(variable)\n            self.add_variable_to_model(linopy_variable)\n\n    def _get_linopy_variable_params(self, variable: ModelVariable) -&gt; LinopyVariableParameters:\n        coordinates = {}\n        dimensions = []\n        indeces = []\n\n        for dimension in variable.dimensions:\n            index = self.get_index_for_dimension(dimension)\n            coordinates |= index.coordinates\n            dimensions.append(index.dimension)\n            indeces.append(index)\n\n        return LinopyVariableParameters(\n            name=variable.var_name,\n            coords=coordinates,\n            dims=dimensions,\n            lower=get_variable_lower_bound(\n                indeces=indeces,\n                lower_bound_type=variable.lower_bound_type,\n                is_binary=variable.is_binary,\n            ),\n            binary=variable.is_binary,\n        )\n\n    def get_index_for_dimension(self, dimension: ModelDimension) -&gt; ModelIndex:\n        \"\"\"Return the model index corresponding to a given dimension.\n\n        Args:\n            dimension: The model dimension to look up.\n\n        Raises:\n            ValueError: If no index exists for the given dimension.\n\n        \"\"\"\n        index = self._dimension_to_index_mapping.get(dimension)\n        if index is None:\n            msg = f\"No index found for dimension '{dimension}'.\"\n            raise ValueError(msg)\n        return index\n\n    @cached_property\n    def _dimension_to_index_mapping(self) -&gt; dict[ModelDimension, ModelIndex | None]:\n        return {\n            ModelDimension.Scenarios: self._milp_model.indices.scenarios,\n            ModelDimension.Time: self._milp_model.indices.time,\n            ModelDimension.Generators: self._milp_model.indices.generators,\n            ModelDimension.Batteries: self._milp_model.indices.batteries,\n            ModelDimension.Loads: self._milp_model.indices.loads,\n            ModelDimension.Markets: self._milp_model.indices.markets,\n        }\n\n    def add_variable_to_model(self, variable: LinopyVariableParameters) -&gt; None:\n        \"\"\"Add a variable to the underlying linopy model.\"\"\"\n        self._milp_model.linopy_model.add_variables(\n            name=variable.name,\n            coords=variable.coords,\n            dims=variable.dims,\n            lower=variable.lower,\n            binary=variable.binary,\n        )\n\n    def _add_model_constraints(self) -&gt; None:\n        self._add_generator_constraints()\n        self._add_battery_constraints()\n        self._add_market_constraints()\n        self._add_scenario_constraints()\n\n    def _add_battery_constraints(self) -&gt; None:\n        constraints = BatteryConstraints(milp_model=self._milp_model).all\n        self._add_set_of_contraints_to_model(constraints)\n\n    def _add_generator_constraints(self) -&gt; None:\n        constraints = GeneratorConstraints(self._milp_model).all\n        self._add_set_of_contraints_to_model(constraints)\n\n    def _add_market_constraints(self) -&gt; None:\n        constraints = MarketConstraints(milp_model=self._milp_model).all\n        self._add_set_of_contraints_to_model(constraints)\n\n    def _add_scenario_constraints(self) -&gt; None:\n        constraints = ScenarioConstraints(\n            milp_model=self._milp_model,\n        ).all\n        self._add_set_of_contraints_to_model(constraints)\n\n    def _add_set_of_contraints_to_model(self, constraints: Iterable[ModelConstraint]) -&gt; None:\n        for constraint in constraints:\n            self._milp_model.linopy_model.add_constraints(\n                constraint.constraint,\n                name=constraint.name,\n            )\n\n    def _add_model_objective(self) -&gt; None:\n        objective = ObjectiveFunction(milp_model=self._milp_model).profit\n        self._milp_model.linopy_model.add_objective(objective, sense=\"max\")\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_builder.EnergyAlgebraicModelBuilder.__init__","title":"<code>__init__(energy_system_parameters)</code>","text":"<p>Initialize the model builder with validated energy system.</p> <p>Parameters:</p> Name Type Description Default <code>energy_system_parameters</code> <code>EnergySystemParameters</code> <p>Parameters of the energy system, containing all assets, demand profiles, and constraints.</p> required Source code in <code>src/odys/math_model/model_builder.py</code> <pre><code>def __init__(\n    self,\n    energy_system_parameters: EnergySystemParameters,\n) -&gt; None:\n    \"\"\"Initialize the model builder with validated energy system.\n\n    Args:\n        energy_system_parameters: Parameters of the energy system,\n            containing all assets, demand profiles, and constraints.\n    \"\"\"\n    self._milp_model = EnergyMILPModel(energy_system_parameters)\n    self._model_is_built: bool = False\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_builder.EnergyAlgebraicModelBuilder.add_variable_to_model","title":"<code>add_variable_to_model(variable)</code>","text":"<p>Add a variable to the underlying linopy model.</p> Source code in <code>src/odys/math_model/model_builder.py</code> <pre><code>def add_variable_to_model(self, variable: LinopyVariableParameters) -&gt; None:\n    \"\"\"Add a variable to the underlying linopy model.\"\"\"\n    self._milp_model.linopy_model.add_variables(\n        name=variable.name,\n        coords=variable.coords,\n        dims=variable.dims,\n        lower=variable.lower,\n        binary=variable.binary,\n    )\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_builder.EnergyAlgebraicModelBuilder.build","title":"<code>build()</code>","text":"<p>Build the complete optimization model with variables, constraints, and objective.</p> <p>Returns:</p> Type Description <code>EnergyMILPModel</code> <p>The fully constructed EnergyMILPModel ready for solving.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the model has already been built.</p> Source code in <code>src/odys/math_model/model_builder.py</code> <pre><code>def build(self) -&gt; EnergyMILPModel:\n    \"\"\"Build the complete optimization model with variables, constraints, and objective.\n\n    Returns:\n        The fully constructed EnergyMILPModel ready for solving.\n\n    Raises:\n        AttributeError: If the model has already been built.\n\n    \"\"\"\n    if self._model_is_built:\n        msg = \"Model has already been built.\"\n        raise AttributeError(msg)\n    self._add_model_variables()\n    self._add_model_constraints()\n    self._add_model_objective()\n    self._model_is_built = True\n\n    return self._milp_model\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_builder.EnergyAlgebraicModelBuilder.get_index_for_dimension","title":"<code>get_index_for_dimension(dimension)</code>","text":"<p>Return the model index corresponding to a given dimension.</p> <p>Parameters:</p> Name Type Description Default <code>dimension</code> <code>ModelDimension</code> <p>The model dimension to look up.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If no index exists for the given dimension.</p> Source code in <code>src/odys/math_model/model_builder.py</code> <pre><code>def get_index_for_dimension(self, dimension: ModelDimension) -&gt; ModelIndex:\n    \"\"\"Return the model index corresponding to a given dimension.\n\n    Args:\n        dimension: The model dimension to look up.\n\n    Raises:\n        ValueError: If no index exists for the given dimension.\n\n    \"\"\"\n    index = self._dimension_to_index_mapping.get(dimension)\n    if index is None:\n        msg = f\"No index found for dimension '{dimension}'.\"\n        raise ValueError(msg)\n    return index\n</code></pre>"},{"location":"api/math_model/#milp-model","title":"MILP Model","text":"<p>MILP model representation for energy system optimization.</p> <p>This module provides the EnergyMILPModel class that wraps a linopy Model with typed accessors for energy system decision variables.</p>"},{"location":"api/math_model/#odys.math_model.milp_model.EnergyMILPModel","title":"<code>EnergyMILPModel</code>","text":"<p>Wrapper around a linopy Model with typed variable accessors for energy systems.</p> Source code in <code>src/odys/math_model/milp_model.py</code> <pre><code>class EnergyMILPModel:\n    \"\"\"Wrapper around a linopy Model with typed variable accessors for energy systems.\"\"\"\n\n    def __init__(self, parameters: EnergySystemParameters) -&gt; None:\n        \"\"\"Initialize the MILP model with energy system parameters.\n\n        Args:\n            parameters: Validated energy system parameters.\n\n        \"\"\"\n        self._parameters = parameters\n        self._linopy_model = Model(force_dim_names=True)\n\n    @cached_property\n    def indices(self) -&gt; EnergyModelIndices:\n        \"\"\"Return all dimension indices for the model.\"\"\"\n        return EnergyModelIndices(\n            scenarios=self._parameters.scenarios.scenario_index,\n            time=self._parameters.scenarios.time_index,\n            generators=self._parameters.generators.index if self._parameters.generators is not None else None,\n            batteries=self._parameters.batteries.index if self._parameters.batteries is not None else None,\n            loads=self._parameters.loads.index if self._parameters.loads is not None else None,\n            markets=self._parameters.markets.index if self._parameters.markets is not None else None,\n        )\n\n    @property\n    def linopy_model(self) -&gt; Model:\n        \"\"\"Return the underlying linopy model.\"\"\"\n        return self._linopy_model\n\n    @property\n    def parameters(self) -&gt; EnergySystemParameters:\n        \"\"\"Return the energy system parameters.\"\"\"\n        return self._parameters\n\n    @property\n    def generator_power(self) -&gt; Variable:\n        \"\"\"Return the generator power output variable.\"\"\"\n        return self._linopy_model.variables[ModelVariable.GENERATOR_POWER.var_name]\n\n    @property\n    def generator_status(self) -&gt; Variable:\n        \"\"\"Return the generator on/off status variable.\"\"\"\n        return self._linopy_model.variables[ModelVariable.GENERATOR_STATUS.var_name]\n\n    @property\n    def generator_startup(self) -&gt; Variable:\n        \"\"\"Return the generator startup indicator variable.\"\"\"\n        return self._linopy_model.variables[ModelVariable.GENERATOR_STARTUP.var_name]\n\n    @property\n    def generator_shutdown(self) -&gt; Variable:\n        \"\"\"Return the generator shutdown indicator variable.\"\"\"\n        return self._linopy_model.variables[ModelVariable.GENERATOR_SHUTDOWN.var_name]\n\n    @property\n    def battery_power_in(self) -&gt; Variable:\n        \"\"\"Return the battery charging power variable.\"\"\"\n        return self._linopy_model.variables[ModelVariable.BATTERY_POWER_IN.var_name]\n\n    @property\n    def battery_power_net(self) -&gt; Variable:\n        \"\"\"Return the battery net power variable (charge - discharge).\"\"\"\n        return self._linopy_model.variables[ModelVariable.BATTERY_POWER_NET.var_name]\n\n    @property\n    def battery_power_out(self) -&gt; Variable:\n        \"\"\"Return the battery discharging power variable.\"\"\"\n        return self._linopy_model.variables[ModelVariable.BATTERY_POWER_OUT.var_name]\n\n    @property\n    def battery_soc(self) -&gt; Variable:\n        \"\"\"Return the battery state of charge variable.\"\"\"\n        return self._linopy_model.variables[ModelVariable.BATTERY_SOC.var_name]\n\n    @property\n    def battery_charge_mode(self) -&gt; Variable:\n        \"\"\"Return the battery charge/discharge mode indicator variable.\"\"\"\n        return self._linopy_model.variables[ModelVariable.BATTERY_CHARGE_MODE.var_name]\n\n    @property\n    def market_sell_volume(self) -&gt; Variable:\n        \"\"\"Return the market sell volume variable.\"\"\"\n        return self._linopy_model.variables[ModelVariable.MARKET_SELL.var_name]\n\n    @property\n    def market_buy_volume(self) -&gt; Variable:\n        \"\"\"Return the market buy volume variable.\"\"\"\n        return self._linopy_model.variables[ModelVariable.MARKET_BUY.var_name]\n\n    @property\n    def market_trade_mode(self) -&gt; Variable:\n        \"\"\"Return the market buy/sell mode indicator variable.\"\"\"\n        return self._linopy_model.variables[ModelVariable.MARKET_TRADE_MODE.var_name]\n</code></pre>"},{"location":"api/math_model/#odys.math_model.milp_model.EnergyMILPModel.battery_charge_mode","title":"<code>battery_charge_mode</code>  <code>property</code>","text":"<p>Return the battery charge/discharge mode indicator variable.</p>"},{"location":"api/math_model/#odys.math_model.milp_model.EnergyMILPModel.battery_power_in","title":"<code>battery_power_in</code>  <code>property</code>","text":"<p>Return the battery charging power variable.</p>"},{"location":"api/math_model/#odys.math_model.milp_model.EnergyMILPModel.battery_power_net","title":"<code>battery_power_net</code>  <code>property</code>","text":"<p>Return the battery net power variable (charge - discharge).</p>"},{"location":"api/math_model/#odys.math_model.milp_model.EnergyMILPModel.battery_power_out","title":"<code>battery_power_out</code>  <code>property</code>","text":"<p>Return the battery discharging power variable.</p>"},{"location":"api/math_model/#odys.math_model.milp_model.EnergyMILPModel.battery_soc","title":"<code>battery_soc</code>  <code>property</code>","text":"<p>Return the battery state of charge variable.</p>"},{"location":"api/math_model/#odys.math_model.milp_model.EnergyMILPModel.generator_power","title":"<code>generator_power</code>  <code>property</code>","text":"<p>Return the generator power output variable.</p>"},{"location":"api/math_model/#odys.math_model.milp_model.EnergyMILPModel.generator_shutdown","title":"<code>generator_shutdown</code>  <code>property</code>","text":"<p>Return the generator shutdown indicator variable.</p>"},{"location":"api/math_model/#odys.math_model.milp_model.EnergyMILPModel.generator_startup","title":"<code>generator_startup</code>  <code>property</code>","text":"<p>Return the generator startup indicator variable.</p>"},{"location":"api/math_model/#odys.math_model.milp_model.EnergyMILPModel.generator_status","title":"<code>generator_status</code>  <code>property</code>","text":"<p>Return the generator on/off status variable.</p>"},{"location":"api/math_model/#odys.math_model.milp_model.EnergyMILPModel.indices","title":"<code>indices</code>  <code>cached</code> <code>property</code>","text":"<p>Return all dimension indices for the model.</p>"},{"location":"api/math_model/#odys.math_model.milp_model.EnergyMILPModel.linopy_model","title":"<code>linopy_model</code>  <code>property</code>","text":"<p>Return the underlying linopy model.</p>"},{"location":"api/math_model/#odys.math_model.milp_model.EnergyMILPModel.market_buy_volume","title":"<code>market_buy_volume</code>  <code>property</code>","text":"<p>Return the market buy volume variable.</p>"},{"location":"api/math_model/#odys.math_model.milp_model.EnergyMILPModel.market_sell_volume","title":"<code>market_sell_volume</code>  <code>property</code>","text":"<p>Return the market sell volume variable.</p>"},{"location":"api/math_model/#odys.math_model.milp_model.EnergyMILPModel.market_trade_mode","title":"<code>market_trade_mode</code>  <code>property</code>","text":"<p>Return the market buy/sell mode indicator variable.</p>"},{"location":"api/math_model/#odys.math_model.milp_model.EnergyMILPModel.parameters","title":"<code>parameters</code>  <code>property</code>","text":"<p>Return the energy system parameters.</p>"},{"location":"api/math_model/#odys.math_model.milp_model.EnergyMILPModel.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Initialize the MILP model with energy system parameters.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>EnergySystemParameters</code> <p>Validated energy system parameters.</p> required Source code in <code>src/odys/math_model/milp_model.py</code> <pre><code>def __init__(self, parameters: EnergySystemParameters) -&gt; None:\n    \"\"\"Initialize the MILP model with energy system parameters.\n\n    Args:\n        parameters: Validated energy system parameters.\n\n    \"\"\"\n    self._parameters = parameters\n    self._linopy_model = Model(force_dim_names=True)\n</code></pre>"},{"location":"api/math_model/#odys.math_model.milp_model.EnergyModelIndices","title":"<code>EnergyModelIndices</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Collection of all dimension indices used in the optimization model.</p> Source code in <code>src/odys/math_model/milp_model.py</code> <pre><code>class EnergyModelIndices(BaseModel):\n    \"\"\"Collection of all dimension indices used in the optimization model.\"\"\"\n\n    model_config = ConfigDict(frozen=True, extra=\"forbid\")\n\n    scenarios: ScenarioIndex\n    time: TimeIndex\n    generators: GeneratorIndex | None\n    batteries: BatteryIndex | None\n    loads: LoadIndex | None\n    markets: MarketIndex | None\n</code></pre>"},{"location":"api/math_model/#sets","title":"Sets","text":"<p>Set and index definitions for the optimization model dimensions.</p>"},{"location":"api/math_model/#odys.math_model.model_components.sets.ModelDimension","title":"<code>ModelDimension</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Dimension names used as axes in the optimization model.</p> Source code in <code>src/odys/math_model/model_components/sets.py</code> <pre><code>class ModelDimension(StrEnum):\n    \"\"\"Dimension names used as axes in the optimization model.\"\"\"\n\n    Scenarios = \"scenario\"\n    Time = \"time\"\n    Generators = \"generator\"\n    Batteries = \"battery\"\n    Loads = \"load\"\n    Markets = \"market\"\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.sets.ModelIndex","title":"<code>ModelIndex</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>ABC</code></p> <p>Energy Model Set.</p> Source code in <code>src/odys/math_model/model_components/sets.py</code> <pre><code>class ModelIndex(BaseModel, ABC):  # pyright: ignore[reportUnsafeMultipleInheritance]\n    \"\"\"Energy Model Set.\"\"\"\n\n    dimension: ClassVar[ModelDimension]\n    model_config = ConfigDict(frozen=True)\n    values: tuple[str, ...]\n\n    @property\n    def coordinates(self) -&gt; dict[str, list[str]]:\n        \"\"\"Gets coordinates for xarray objects.\"\"\"\n        return {f\"{self.dimension}\": list(self.values)}\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.sets.ModelIndex.coordinates","title":"<code>coordinates</code>  <code>property</code>","text":"<p>Gets coordinates for xarray objects.</p>"},{"location":"api/math_model/#variables","title":"Variables","text":"<p>Variable definitions for energy system optimization models.</p> <p>This module defines variable names and types used in energy system optimization models.</p>"},{"location":"api/math_model/#odys.math_model.model_components.variables.BoundType","title":"<code>BoundType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Lower bound type for optimization variables.</p> Source code in <code>src/odys/math_model/model_components/variables.py</code> <pre><code>class BoundType(Enum):\n    \"\"\"Lower bound type for optimization variables.\"\"\"\n\n    NON_NEGATIVE = \"non_negative\"\n    UNBOUNDED = \"unbounded\"\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.variables.ModelVariable","title":"<code>ModelVariable</code>","text":"<p>               Bases: <code>Enum</code></p> <p>All decision variables in the energy system optimization model.</p> Source code in <code>src/odys/math_model/model_components/variables.py</code> <pre><code>@unique\nclass ModelVariable(Enum):\n    \"\"\"All decision variables in the energy system optimization model.\"\"\"\n\n    GENERATOR_POWER = VariableSpec(\n        name=\"generator_power\",\n        is_binary=False,\n        dimensions=[ModelDimension.Scenarios, ModelDimension.Time, ModelDimension.Generators],\n        lower_bound_type=BoundType.NON_NEGATIVE,\n    )\n    GENERATOR_STATUS = VariableSpec(\n        name=\"generator_status\",\n        is_binary=True,\n        dimensions=[ModelDimension.Scenarios, ModelDimension.Time, ModelDimension.Generators],\n        lower_bound_type=BoundType.UNBOUNDED,\n    )\n    GENERATOR_STARTUP = VariableSpec(\n        name=\"generator_startup\",\n        is_binary=True,\n        dimensions=[ModelDimension.Scenarios, ModelDimension.Time, ModelDimension.Generators],\n        lower_bound_type=BoundType.UNBOUNDED,\n    )\n    GENERATOR_SHUTDOWN = VariableSpec(\n        name=\"generator_shutdown\",\n        is_binary=True,\n        dimensions=[ModelDimension.Scenarios, ModelDimension.Time, ModelDimension.Generators],\n        lower_bound_type=BoundType.UNBOUNDED,\n    )\n    BATTERY_POWER_IN = VariableSpec(\n        name=\"battery_power_in\",\n        is_binary=False,\n        dimensions=[ModelDimension.Scenarios, ModelDimension.Time, ModelDimension.Batteries],\n        lower_bound_type=BoundType.NON_NEGATIVE,\n    )\n    BATTERY_POWER_NET = VariableSpec(\n        name=\"battery_net_power\",\n        is_binary=False,\n        dimensions=[ModelDimension.Scenarios, ModelDimension.Time, ModelDimension.Batteries],\n        lower_bound_type=BoundType.UNBOUNDED,\n    )\n    BATTERY_POWER_OUT = VariableSpec(\n        name=\"battery_power_out\",\n        is_binary=False,\n        dimensions=[ModelDimension.Scenarios, ModelDimension.Time, ModelDimension.Batteries],\n        lower_bound_type=BoundType.NON_NEGATIVE,\n    )\n    BATTERY_SOC = VariableSpec(\n        name=\"battery_soc\",\n        is_binary=False,\n        dimensions=[ModelDimension.Scenarios, ModelDimension.Time, ModelDimension.Batteries],\n        lower_bound_type=BoundType.NON_NEGATIVE,\n    )\n    BATTERY_CHARGE_MODE = VariableSpec(\n        name=\"battery_charge_mode\",\n        is_binary=True,\n        dimensions=[ModelDimension.Scenarios, ModelDimension.Time, ModelDimension.Batteries],\n        lower_bound_type=BoundType.UNBOUNDED,\n    )\n    MARKET_SELL = VariableSpec(\n        name=\"market_sell_volume\",\n        is_binary=False,\n        dimensions=[ModelDimension.Scenarios, ModelDimension.Time, ModelDimension.Markets],\n        lower_bound_type=BoundType.NON_NEGATIVE,\n    )\n    MARKET_BUY = VariableSpec(\n        name=\"market_buy_volume\",\n        is_binary=False,\n        dimensions=[ModelDimension.Scenarios, ModelDimension.Time, ModelDimension.Markets],\n        lower_bound_type=BoundType.NON_NEGATIVE,\n    )\n    MARKET_TRADE_MODE = VariableSpec(\n        name=\"market_trade_mode\",\n        is_binary=True,\n        dimensions=[ModelDimension.Scenarios, ModelDimension.Time, ModelDimension.Markets],\n        lower_bound_type=BoundType.UNBOUNDED,\n    )\n\n    @property\n    def var_name(self) -&gt; str:\n        \"\"\"Return the variable name used in the linopy model.\"\"\"\n        return self.value.name\n\n    @property\n    def dimensions(self) -&gt; list[ModelDimension]:\n        \"\"\"Return the dimensions this variable is defined over.\"\"\"\n        return self.value.dimensions\n\n    @property\n    def asset_dimension(self) -&gt; ModelDimension | None:\n        \"\"\"Get the asset dimension (Generators or Batteries) if present.\"\"\"\n        for dim in self.value.dimensions:\n            if dim in (ModelDimension.Generators, ModelDimension.Batteries):\n                return dim\n        return None\n\n    @property\n    def lower_bound_type(self) -&gt; BoundType:\n        \"\"\"Return the lower bound type for this variable.\"\"\"\n        return self.value.lower_bound_type\n\n    @property\n    def is_binary(self) -&gt; bool:\n        \"\"\"Return whether this variable is binary.\"\"\"\n        return self.value.is_binary\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.variables.ModelVariable.asset_dimension","title":"<code>asset_dimension</code>  <code>property</code>","text":"<p>Get the asset dimension (Generators or Batteries) if present.</p>"},{"location":"api/math_model/#odys.math_model.model_components.variables.ModelVariable.dimensions","title":"<code>dimensions</code>  <code>property</code>","text":"<p>Return the dimensions this variable is defined over.</p>"},{"location":"api/math_model/#odys.math_model.model_components.variables.ModelVariable.is_binary","title":"<code>is_binary</code>  <code>property</code>","text":"<p>Return whether this variable is binary.</p>"},{"location":"api/math_model/#odys.math_model.model_components.variables.ModelVariable.lower_bound_type","title":"<code>lower_bound_type</code>  <code>property</code>","text":"<p>Return the lower bound type for this variable.</p>"},{"location":"api/math_model/#odys.math_model.model_components.variables.ModelVariable.var_name","title":"<code>var_name</code>  <code>property</code>","text":"<p>Return the variable name used in the linopy model.</p>"},{"location":"api/math_model/#odys.math_model.model_components.variables.VariableSpec","title":"<code>VariableSpec</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Specification for an optimization variable (name, type, dimensions, bounds).</p> Source code in <code>src/odys/math_model/model_components/variables.py</code> <pre><code>class VariableSpec(BaseModel):\n    \"\"\"Specification for an optimization variable (name, type, dimensions, bounds).\"\"\"\n\n    model_config = ConfigDict()\n\n    name: str\n    is_binary: bool\n    dimensions: list[ModelDimension]\n    lower_bound_type: BoundType\n</code></pre>"},{"location":"api/math_model/#objectives","title":"Objectives","text":"<p>Objective function definitions for energy system optimization models.</p> <p>This module defines objective function names and types used in energy system optimization models.</p>"},{"location":"api/math_model/#odys.math_model.model_components.objectives.ObjectiveFunction","title":"<code>ObjectiveFunction</code>","text":"<p>Builds the objective function for the energy system optimization model.</p> Source code in <code>src/odys/math_model/model_components/objectives.py</code> <pre><code>class ObjectiveFunction:\n    \"\"\"Builds the objective function for the energy system optimization model.\"\"\"\n\n    def __init__(self, milp_model: EnergyMILPModel) -&gt; None:\n        \"\"\"Initialize with the MILP model to build the objective from.\"\"\"\n        self._model = milp_model\n\n    @property\n    def profit(self) -&gt; linopy.LinearExpression:\n        \"\"\"Build the total profit expression (market revenue minus operating costs).\"\"\"\n        profit = 0\n\n        if self._model.parameters.scenarios.market_prices is not None:\n            profit += self.get_market_revenue()\n\n        if self._model.parameters.generators is not None:\n            profit += -self.get_operating_costs()\n\n        if isinstance(profit, int) and profit == 0:\n            msg = \"No terms added to profit\"\n            raise ValueError(msg)\n        return profit\n\n    def get_market_revenue(self) -&gt; linopy.LinearExpression:\n        \"\"\"Calculate expected market revenue across all scenarios.\"\"\"\n        return (\n            (self._model.market_sell_volume - self._model.market_buy_volume)  # pyrefly: ignore\n            * self._model.parameters.scenarios.market_prices  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOperatorIssue]\n            * self._model.parameters.scenarios.scenario_probabilities\n        ).sum([ModelDimension.Scenarios, ModelDimension.Time, ModelDimension.Markets])\n\n    def get_operating_costs(self) -&gt; linopy.LinearExpression:\n        \"\"\"Calculate total generator operating costs (variable + startup).\"\"\"\n        return (\n            self._model.generator_power * self._model.parameters.generators.variable_cost  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n            + self._model.generator_startup * self._model.parameters.generators.startup_cost  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n        ).sum([ModelDimension.Scenarios, ModelDimension.Time, ModelDimension.Generators])\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.objectives.ObjectiveFunction.profit","title":"<code>profit</code>  <code>property</code>","text":"<p>Build the total profit expression (market revenue minus operating costs).</p>"},{"location":"api/math_model/#odys.math_model.model_components.objectives.ObjectiveFunction.__init__","title":"<code>__init__(milp_model)</code>","text":"<p>Initialize with the MILP model to build the objective from.</p> Source code in <code>src/odys/math_model/model_components/objectives.py</code> <pre><code>def __init__(self, milp_model: EnergyMILPModel) -&gt; None:\n    \"\"\"Initialize with the MILP model to build the objective from.\"\"\"\n    self._model = milp_model\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.objectives.ObjectiveFunction.get_market_revenue","title":"<code>get_market_revenue()</code>","text":"<p>Calculate expected market revenue across all scenarios.</p> Source code in <code>src/odys/math_model/model_components/objectives.py</code> <pre><code>def get_market_revenue(self) -&gt; linopy.LinearExpression:\n    \"\"\"Calculate expected market revenue across all scenarios.\"\"\"\n    return (\n        (self._model.market_sell_volume - self._model.market_buy_volume)  # pyrefly: ignore\n        * self._model.parameters.scenarios.market_prices  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOperatorIssue]\n        * self._model.parameters.scenarios.scenario_probabilities\n    ).sum([ModelDimension.Scenarios, ModelDimension.Time, ModelDimension.Markets])\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.objectives.ObjectiveFunction.get_operating_costs","title":"<code>get_operating_costs()</code>","text":"<p>Calculate total generator operating costs (variable + startup).</p> Source code in <code>src/odys/math_model/model_components/objectives.py</code> <pre><code>def get_operating_costs(self) -&gt; linopy.LinearExpression:\n    \"\"\"Calculate total generator operating costs (variable + startup).\"\"\"\n    return (\n        self._model.generator_power * self._model.parameters.generators.variable_cost  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n        + self._model.generator_startup * self._model.parameters.generators.startup_cost  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n    ).sum([ModelDimension.Scenarios, ModelDimension.Time, ModelDimension.Generators])\n</code></pre>"},{"location":"api/math_model/#constraints","title":"Constraints","text":""},{"location":"api/math_model/#model-constraint","title":"Model Constraint","text":"<p>Named constraint wrapper for linopy constraints.</p>"},{"location":"api/math_model/#odys.math_model.model_components.constraints.model_constraint.ModelConstraint","title":"<code>ModelConstraint</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A named linopy constraint ready to be added to the model.</p> Source code in <code>src/odys/math_model/model_components/constraints/model_constraint.py</code> <pre><code>class ModelConstraint(BaseModel):\n    \"\"\"A named linopy constraint ready to be added to the model.\"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    constraint: linopy.Constraint\n    name: str\n</code></pre>"},{"location":"api/math_model/#generator-constraints","title":"Generator Constraints","text":"<p>Generator-related constraints for the optimization model.</p>"},{"location":"api/math_model/#odys.math_model.model_components.constraints.generator_constraints.GeneratorConstraints","title":"<code>GeneratorConstraints</code>","text":"<p>Builds constraints for generator power limits, ramping, startup/shutdown, and min uptime.</p> Source code in <code>src/odys/math_model/model_components/constraints/generator_constraints.py</code> <pre><code>class GeneratorConstraints:\n    \"\"\"Builds constraints for generator power limits, ramping, startup/shutdown, and min uptime.\"\"\"\n\n    def __init__(self, milp_model: EnergyMILPModel) -&gt; None:\n        \"\"\"Initialize with the MILP model containing generator variables and parameters.\"\"\"\n        self.model = milp_model\n        self.params = milp_model.parameters.generators\n\n    def _validate_generator_parameters_exist(self) -&gt; None:\n        if self.params is None:\n            msg = \"No generator parameters specified.\"\n            raise ValueError(msg)\n\n    @property\n    def all(self) -&gt; tuple[ModelConstraint, ...]:\n        \"\"\"Return all generator constraints, or an empty tuple if no generators exist.\"\"\"\n        if self.params is None:\n            return ()\n        return (\n            self._get_generator_max_power_constraint(),\n            self._get_generator_status_constraint(),\n            self._get_generator_startup_lower_bound_constraint(),\n            self._get_generator_startup_upper_bound_1_constraint(),\n            self._get_generator_startup_upper_bound_2_constraint(),\n            self._get_generator_shutdown_lower_bound_constraint(),\n            self._get_generator_shutdown_upper_bound_1_constraint(),\n            self._get_generator_shutdown_upper_bound_2_constraint(),\n            *self._get_min_uptime_constraint(),\n            self._get_min_power_constraint(),\n            self._get_max_ramp_up_constraint(),\n            self._get_max_ramp_down_constraint(),\n        )\n\n    def _get_generator_max_power_constraint(self) -&gt; ModelConstraint:\n        \"\"\"Generator power limit constraint.\n\n        This constraint ensures that each generator's power output does not\n        exceed its nominal power capacity.\n        \"\"\"\n        self._validate_generator_parameters_exist()\n        constraint = self.model.generator_power - self.model.generator_status * self.params.nominal_power &lt;= 0  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n        return ModelConstraint(\n            constraint=constraint,\n            name=\"generator_max_power_constraint\",\n        )\n\n    def _get_generator_status_constraint(self) -&gt; ModelConstraint:\n        self._validate_generator_parameters_exist()\n        epsilon = 1e-5 * self.params.nominal_power  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n        constraint = self.model.generator_power &gt;= self.model.generator_status * epsilon\n        return ModelConstraint(\n            constraint=constraint,\n            name=\"generator_status_constraint\",\n        )\n\n    def _get_generator_startup_lower_bound_constraint(self) -&gt; ModelConstraint:\n        constraint = self.model.generator_startup &gt;= self.model.generator_status - self.model.generator_status.shift(\n            time=1,\n        )\n        return ModelConstraint(\n            constraint=constraint,\n            name=\"generator_startup_lower_bound_constraint\",\n        )\n\n    def _get_generator_startup_upper_bound_1_constraint(self) -&gt; ModelConstraint:\n        return ModelConstraint(\n            constraint=self.model.generator_startup &lt;= self.model.generator_status,\n            name=\"generator_startup_upper_bound_1_constraint\",\n        )\n\n    def _get_generator_startup_upper_bound_2_constraint(self) -&gt; ModelConstraint:\n        return ModelConstraint(\n            constraint=self.model.generator_startup + self.model.generator_status.shift(time=1) &lt;= 1.0,\n            name=\"generator_startup_upper_bound_2_constraint\",\n        )\n\n    def _get_generator_shutdown_lower_bound_constraint(self) -&gt; ModelConstraint:\n        constraint = (\n            self.model.generator_shutdown &gt;= self.model.generator_status.shift(time=1) - self.model.generator_status\n        )\n        return ModelConstraint(\n            constraint=constraint,\n            name=\"generator_shutdown_lower_bound_constraint\",\n        )\n\n    def _get_generator_shutdown_upper_bound_1_constraint(self) -&gt; ModelConstraint:\n        return ModelConstraint(\n            constraint=self.model.generator_shutdown &lt;= self.model.generator_status.shift(time=1),\n            name=\"generator_shutdown_upper_bound_1_constraint\",\n        )\n\n    def _get_generator_shutdown_upper_bound_2_constraint(self) -&gt; ModelConstraint:\n        return ModelConstraint(\n            constraint=self.model.generator_shutdown + self.model.generator_status &lt;= 1.0,\n            name=\"generator_shutdown_upper_bound_2_constraint\",\n        )\n\n    def _get_min_uptime_constraint(self) -&gt; list[ModelConstraint]:\n        self._validate_generator_parameters_exist()\n        constraints = []\n        for generator in self.params.index.values:  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n            min_up_time = int(self.params.min_up_time.sel(generator=generator))  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n            generator_status = self.model.generator_status.sel(generator=generator)\n            generator_shutdown = self.model.generator_shutdown.sel(generator=generator)\n            constraint_generator = generator_status.rolling(\n                time=min_up_time,\n            ).sum() &gt;= min_up_time * generator_shutdown.shift(time=-1)\n            constraints.append(\n                ModelConstraint(\n                    constraint=constraint_generator,\n                    name=f\"generator_min_uptime_{generator}_constraint\",\n                ),\n            )\n\n        return constraints\n\n    def _get_min_power_constraint(self) -&gt; ModelConstraint:\n        self._validate_generator_parameters_exist()\n        return ModelConstraint(\n            constraint=self.model.generator_power &gt;= self.params.min_power * self.model.generator_status,  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n            name=\"generator_min_power_constraint\",\n        )\n\n    def _get_max_ramp_up_constraint(self) -&gt; ModelConstraint:\n        self._validate_generator_parameters_exist()\n        max_ramp_up = self.params.max_ramp_up.fillna(self.params.nominal_power)  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n        return ModelConstraint(\n            constraint=self.model.generator_power - self.model.generator_power.shift(time=1) &lt;= max_ramp_up,\n            name=\"generator_max_ramp_up_constraint\",\n        )\n\n    def _get_max_ramp_down_constraint(self) -&gt; ModelConstraint:\n        self._validate_generator_parameters_exist()\n        max_ramp_down = self.params.max_ramp_down.fillna(self.params.nominal_power)  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n        constraint = self.model.generator_power.shift(time=1) - self.model.generator_power &lt;= max_ramp_down\n\n        return ModelConstraint(\n            constraint=constraint,\n            name=\"generator_max_ramp_down_constraint\",\n        )\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.constraints.generator_constraints.GeneratorConstraints.all","title":"<code>all</code>  <code>property</code>","text":"<p>Return all generator constraints, or an empty tuple if no generators exist.</p>"},{"location":"api/math_model/#odys.math_model.model_components.constraints.generator_constraints.GeneratorConstraints.__init__","title":"<code>__init__(milp_model)</code>","text":"<p>Initialize with the MILP model containing generator variables and parameters.</p> Source code in <code>src/odys/math_model/model_components/constraints/generator_constraints.py</code> <pre><code>def __init__(self, milp_model: EnergyMILPModel) -&gt; None:\n    \"\"\"Initialize with the MILP model containing generator variables and parameters.\"\"\"\n    self.model = milp_model\n    self.params = milp_model.parameters.generators\n</code></pre>"},{"location":"api/math_model/#battery-constraints","title":"Battery Constraints","text":"<p>Battery-related constraints for the optimization model.</p>"},{"location":"api/math_model/#odys.math_model.model_components.constraints.battery_constraints.BatteryConstraints","title":"<code>BatteryConstraints</code>","text":"<p>Builds constraints for battery charge/discharge, SOC dynamics, and power limits.</p> Source code in <code>src/odys/math_model/model_components/constraints/battery_constraints.py</code> <pre><code>class BatteryConstraints:\n    \"\"\"Builds constraints for battery charge/discharge, SOC dynamics, and power limits.\"\"\"\n\n    def __init__(self, milp_model: EnergyMILPModel) -&gt; None:\n        \"\"\"Initialize with the MILP model containing battery variables and parameters.\"\"\"\n        self.model = milp_model\n        self.params = milp_model.parameters.batteries\n\n    def _validate_battery_parameters_exist(self) -&gt; None:\n        if self.params is None:\n            msg = \"No battery parameters specified.\"\n            raise ValueError(msg)\n\n    @property\n    def all(self) -&gt; tuple[ModelConstraint, ...]:\n        \"\"\"Return all battery constraints, or an empty tuple if no batteries exist.\"\"\"\n        if self.params is None:\n            return ()\n        return (\n            self._get_battery_max_charge_constraint(),\n            self._get_battery_max_discharge_constraint(),\n            self._get_battery_soc_dynamics_constraint(),\n            self._get_battery_soc_start_constraint(),\n            self._get_battery_soc_end_constraint(),\n            self._get_battery_soc_min_constriant(),\n            self._get_battery_soc_max_constriant(),\n            self._get_battery_capacity_constraint(),\n            self._get_battery_net_power_constraint(),\n        )\n\n    def _get_battery_max_charge_constraint(self) -&gt; ModelConstraint:\n        # var_battery_discharge &lt;= (1 - var_battery_mode) * param_battery_max_power # noqa: ERA001\n        constraint = self.model.battery_power_in &lt;= self.model.battery_charge_mode * self.params.max_power  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n        return ModelConstraint(\n            constraint=constraint,\n            name=\"battery_max_charge_constraint\",\n        )\n\n    def _get_battery_max_discharge_constraint(self) -&gt; ModelConstraint:\n        # var_battery_discharge &lt;= (1 - var_battery_mode) * param_battery_max_power # noqa: ERA001\n        self._validate_battery_parameters_exist()\n        constraint = (\n            self.model.battery_power_out + self.model.battery_charge_mode * self.params.max_power  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n            &lt;= self.params.max_power  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n        )\n        return ModelConstraint(\n            constraint=constraint,\n            name=\"battery_max_discharge_constraint\",\n        )\n\n    def _get_battery_soc_dynamics_constraint(self) -&gt; ModelConstraint:\n        self._validate_battery_parameters_exist()\n        time_coords = self.model.battery_soc.coords[ModelDimension.Time.value]\n        constraint_expr = self.model.battery_soc - (\n            self.model.battery_soc.shift(time=1)\n            + self.params.efficiency_charging * self.model.battery_power_in / self.params.capacity  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n            - 1 / self.params.efficiency_discharging * self.model.battery_power_out / self.params.capacity  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n        )\n\n        constraint = constraint_expr.where(time_coords &gt; time_coords[0]) == 0\n        return ModelConstraint(\n            constraint=constraint,\n            name=\"battery_soc_dynamics_constraint\",\n        )\n\n    def _get_battery_soc_start_constraint(self) -&gt; ModelConstraint:\n        self._validate_battery_parameters_exist()\n        t0 = self.model.battery_soc.coords[ModelDimension.Time.value][0]\n\n        soc_t0 = self.model.battery_soc.sel(time=t0)\n        charge_t0 = self.model.battery_power_in.sel(time=t0)\n        discharge_t0 = self.model.battery_power_out.sel(time=t0)\n\n        constraint_expr = (\n            soc_t0\n            - self.params.soc_start  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n            - self.params.efficiency_charging * charge_t0 / self.params.capacity  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n            + 1 / self.params.efficiency_discharging * discharge_t0 / self.params.capacity  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n        )\n\n        constraint = constraint_expr == 0\n        return ModelConstraint(\n            constraint=constraint,\n            name=\"battery_soc_start_constraint\",\n        )\n\n    def _get_battery_soc_end_constraint(self) -&gt; ModelConstraint:\n        self._validate_battery_parameters_exist()\n        time_coords = self.model.battery_soc.coords[ModelDimension.Time.value]\n        last_time = time_coords.values[-1]\n        constr_expression = self.model.battery_soc.sel(time=last_time) - self.params.soc_end  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n        constraint = constr_expression == 0\n        return ModelConstraint(\n            constraint=constraint,\n            name=\"battery_soc_end_constraint\",\n        )\n\n    def _get_battery_soc_min_constriant(self) -&gt; ModelConstraint:\n        self._validate_battery_parameters_exist()\n        expression = self.model.battery_soc &gt;= self.params.soc_min  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n        return ModelConstraint(\n            constraint=expression,\n            name=\"batter_soc_min_constraint\",\n        )\n\n    def _get_battery_soc_max_constriant(self) -&gt; ModelConstraint:\n        self._validate_battery_parameters_exist()\n        expression = self.model.battery_soc &lt;= self.params.soc_max  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n        return ModelConstraint(\n            constraint=expression,\n            name=\"batter_soc_max_constraint\",\n        )\n\n    def _get_battery_capacity_constraint(self) -&gt; ModelConstraint:\n        self._validate_battery_parameters_exist()\n        constraint = self.model.battery_soc &lt;= 1  # pyrefly: ignore\n        return ModelConstraint(\n            constraint=constraint,\n            name=\"battery_capacity_constraint\",\n        )\n\n    def _get_battery_net_power_constraint(self) -&gt; ModelConstraint:\n        self._validate_battery_parameters_exist()\n        constraint = self.model.battery_power_net == self.model.battery_power_in - self.model.battery_power_out\n        return ModelConstraint(\n            constraint=constraint,\n            name=\"battery_net_power_constraint\",\n        )\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.constraints.battery_constraints.BatteryConstraints.all","title":"<code>all</code>  <code>property</code>","text":"<p>Return all battery constraints, or an empty tuple if no batteries exist.</p>"},{"location":"api/math_model/#odys.math_model.model_components.constraints.battery_constraints.BatteryConstraints.__init__","title":"<code>__init__(milp_model)</code>","text":"<p>Initialize with the MILP model containing battery variables and parameters.</p> Source code in <code>src/odys/math_model/model_components/constraints/battery_constraints.py</code> <pre><code>def __init__(self, milp_model: EnergyMILPModel) -&gt; None:\n    \"\"\"Initialize with the MILP model containing battery variables and parameters.\"\"\"\n    self.model = milp_model\n    self.params = milp_model.parameters.batteries\n</code></pre>"},{"location":"api/math_model/#scenario-constraints","title":"Scenario Constraints","text":"<p>Scenario-level constraints for the optimization model.</p>"},{"location":"api/math_model/#odys.math_model.model_components.constraints.scenario_constraints.ScenarioConstraints","title":"<code>ScenarioConstraints</code>","text":"<p>Builds power balance, available capacity, and non-anticipativity constraints.</p> Source code in <code>src/odys/math_model/model_components/constraints/scenario_constraints.py</code> <pre><code>class ScenarioConstraints:\n    \"\"\"Builds power balance, available capacity, and non-anticipativity constraints.\"\"\"\n\n    def __init__(\n        self,\n        milp_model: EnergyMILPModel,\n    ) -&gt; None:\n        \"\"\"Initialize with the MILP model containing scenario-level variables and parameters.\"\"\"\n        self.model = milp_model\n        self.scenario_params = milp_model.parameters.scenarios\n        self.market_params = milp_model.parameters.markets\n        self._include_generators = bool(milp_model.parameters.generators)\n        self._include_batteries = bool(milp_model.parameters.batteries)\n        self._include_markets = bool(milp_model.parameters.markets)\n\n    @property\n    def all(self) -&gt; tuple[ModelConstraint, ...]:\n        \"\"\"Return all scenario-level constraints (power balance, capacity, non-anticipativity).\"\"\"\n        constraints = [\n            self._get_power_balance_constraint(),\n        ]\n\n        if self._include_generators and self.scenario_params.available_capacity_profiles is not None:\n            constraints.append(self._get_available_capacity_profiles_constraint())\n\n        if self._include_markets:\n            constraints += self._get_non_anticipativity_constraint()\n        return tuple(constraints)\n\n    def _get_power_balance_constraint(self) -&gt; ModelConstraint:\n        \"\"\"Linopy power balance constraint ensuring supply equals demand.\n\n        This constraint ensures that at each time period and scenario, the total power\n        generation plus battery discharge equals the demand plus battery charging.\n        \"\"\"\n        lhs = 0\n        if self._include_generators:\n            lhs += self.model.generator_power.sum(ModelDimension.Generators)\n\n        if self._include_batteries:\n            lhs += self.model.battery_power_out.sum(ModelDimension.Batteries)\n            lhs += -self.model.battery_power_in.sum(ModelDimension.Batteries)\n\n        if self._include_markets:\n            lhs += self.model.market_buy_volume.sum(ModelDimension.Markets)\n            lhs += -self.model.market_sell_volume.sum(ModelDimension.Markets)\n\n        if self.scenario_params.load_profiles is not None:\n            lhs += -self.scenario_params.load_profiles\n\n        return ModelConstraint(\n            name=\"power_balance_constraint\",\n            constraint=lhs == 0,  # ty: ignore  # pyright: ignore[reportArgumentType]\n        )\n\n    def _get_available_capacity_profiles_constraint(self) -&gt; ModelConstraint:\n        var_generator_power = self.model.generator_power\n        expression = var_generator_power &lt;= self.scenario_params.available_capacity_profiles  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOperatorIssue]\n        return ModelConstraint(\n            name=\"available_capacity_constraint\",\n            constraint=expression,\n        )\n\n    def _get_non_anticipativity_constraint(self) -&gt; list[ModelConstraint]:\n        \"\"\"Non-anticipativity constraint ensuring variables have same values across scenarios.\n\n        This constraint enforces that decision variables take the same values across\n        all scenarios, reflecting that decisions are made before uncertainty is revealed.\n        Only applies to markets where stage_fixed is True.\n        \"\"\"\n        constraints = []\n        stage_fixed_markets = self.market_params.stage_fixed  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n\n        for market_var in MARKET_VARIABLES:\n            linopy_var = self.model.linopy_model.variables[market_var.var_name]\n            market_with_fixed_stage_var = linopy_var.where(stage_fixed_markets, drop=True)\n            market_with_fixed_stage_first_scenario_var = market_with_fixed_stage_var.isel({ModelDimension.Scenarios: 0})\n            expression = market_with_fixed_stage_var - market_with_fixed_stage_first_scenario_var == 0\n            constraints.append(\n                ModelConstraint(\n                    name=f\"non_anticipativity_{market_var.var_name}_constraint\",\n                    constraint=expression,\n                ),\n            )\n\n        return constraints\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.constraints.scenario_constraints.ScenarioConstraints.all","title":"<code>all</code>  <code>property</code>","text":"<p>Return all scenario-level constraints (power balance, capacity, non-anticipativity).</p>"},{"location":"api/math_model/#odys.math_model.model_components.constraints.scenario_constraints.ScenarioConstraints.__init__","title":"<code>__init__(milp_model)</code>","text":"<p>Initialize with the MILP model containing scenario-level variables and parameters.</p> Source code in <code>src/odys/math_model/model_components/constraints/scenario_constraints.py</code> <pre><code>def __init__(\n    self,\n    milp_model: EnergyMILPModel,\n) -&gt; None:\n    \"\"\"Initialize with the MILP model containing scenario-level variables and parameters.\"\"\"\n    self.model = milp_model\n    self.scenario_params = milp_model.parameters.scenarios\n    self.market_params = milp_model.parameters.markets\n    self._include_generators = bool(milp_model.parameters.generators)\n    self._include_batteries = bool(milp_model.parameters.batteries)\n    self._include_markets = bool(milp_model.parameters.markets)\n</code></pre>"},{"location":"api/math_model/#market-constraints","title":"Market Constraints","text":"<p>Market-related constraints for the optimization model.</p>"},{"location":"api/math_model/#odys.math_model.model_components.constraints.market_constraints.MarketConstraints","title":"<code>MarketConstraints</code>","text":"<p>Builds constraints for market trading volumes, mutual exclusivity, and trade direction.</p> Source code in <code>src/odys/math_model/model_components/constraints/market_constraints.py</code> <pre><code>class MarketConstraints:\n    \"\"\"Builds constraints for market trading volumes, mutual exclusivity, and trade direction.\"\"\"\n\n    def __init__(self, milp_model: EnergyMILPModel) -&gt; None:\n        \"\"\"Initialize with the MILP model containing market variables and parameters.\"\"\"\n        self.model = milp_model\n        self.params = milp_model.parameters.markets\n\n    def _validate_market_parameters_exist(self) -&gt; None:\n        if self.params is None:\n            msg = \"No parameters specified.\"\n            raise ValueError(msg)\n\n    @property\n    def all(self) -&gt; tuple[ModelConstraint, ...]:\n        \"\"\"Return all market constraints, or an empty tuple if no markets exist.\"\"\"\n        if self.params is None:\n            return ()\n        constraints = [\n            self._get_market_max_buy_volume_constraint(),\n            self._get_market_max_sell_volume_constraint(),\n            self._get_market_mutual_exclusivity_buy_constraint(),\n            self._get_market_mutual_exclusivity_sell_constraint(),\n            *self._get_trade_direction_constraints(),\n        ]\n\n        return tuple(constraints)\n\n    def _get_market_max_sell_volume_constraint(self) -&gt; ModelConstraint:\n        constraint = self.model.market_sell_volume &lt;= self.params.max_volume  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n        return ModelConstraint(\n            constraint=constraint,\n            name=\"market_max_sell_volume_constraint\",\n        )\n\n    def _get_market_max_buy_volume_constraint(self) -&gt; ModelConstraint:\n        constraint = self.model.market_buy_volume &lt;= self.params.max_volume  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n        return ModelConstraint(\n            constraint=constraint,\n            name=\"market_max_buy_volume_constraint\",\n        )\n\n    def _get_market_mutual_exclusivity_sell_constraint(self) -&gt; ModelConstraint:\n        constraint = self.model.market_sell_volume &lt;= self.model.market_trade_mode * self.params.max_volume  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n        return ModelConstraint(\n            constraint=constraint,\n            name=\"market_mutual_exclusivity_sell_constraint\",\n        )\n\n    def _get_market_mutual_exclusivity_buy_constraint(self) -&gt; ModelConstraint:\n        constraint = (\n            self.model.market_buy_volume + self.model.market_trade_mode * self.params.max_volume  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n            &lt;= self.params.max_volume  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n        )\n        return ModelConstraint(\n            constraint=constraint,\n            name=\"market_mutual_exclusivity_buy_constraint\",\n        )\n\n    def _get_trade_direction_constraints(self) -&gt; list[ModelConstraint]:\n        \"\"\"Generate constraints based on trade_direction parameter for each market.\"\"\"\n        constraints = []\n\n        buy_only_mask = self.params.trade_direction == TradeDirection.BUY  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n        sell_constraint = self.model.market_sell_volume.where(buy_only_mask, drop=True) == 0  # pyrefly: ignore\n        constraints.append(\n            ModelConstraint(\n                constraint=sell_constraint,\n                name=\"market_buy_only_constraint\",\n            ),\n        )\n\n        sell_only_mask = self.params.trade_direction == TradeDirection.SELL  # ty: ignore # pyrefly: ignore  # pyright: ignore[reportOptionalMemberAccess]\n        buy_constraint = self.model.market_buy_volume.where(sell_only_mask, drop=True) == 0  # pyrefly: ignore\n        constraints.append(\n            ModelConstraint(\n                constraint=buy_constraint,\n                name=\"market_sell_only_constraint\",\n            ),\n        )\n\n        return constraints\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.constraints.market_constraints.MarketConstraints.all","title":"<code>all</code>  <code>property</code>","text":"<p>Return all market constraints, or an empty tuple if no markets exist.</p>"},{"location":"api/math_model/#odys.math_model.model_components.constraints.market_constraints.MarketConstraints.__init__","title":"<code>__init__(milp_model)</code>","text":"<p>Initialize with the MILP model containing market variables and parameters.</p> Source code in <code>src/odys/math_model/model_components/constraints/market_constraints.py</code> <pre><code>def __init__(self, milp_model: EnergyMILPModel) -&gt; None:\n    \"\"\"Initialize with the MILP model containing market variables and parameters.\"\"\"\n    self.model = milp_model\n    self.params = milp_model.parameters.markets\n</code></pre>"},{"location":"api/math_model/#parameters","title":"Parameters","text":""},{"location":"api/math_model/#energy-system-parameters","title":"Energy System Parameters","text":"<p>Parameter definitions for energy system optimization models.</p> <p>This module defines parameter names and types used in energy system optimization models.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.parameters.EnergySystemParameters","title":"<code>EnergySystemParameters</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Collection of all energy system parameters for optimization models.</p> Source code in <code>src/odys/math_model/model_components/parameters/parameters.py</code> <pre><code>class EnergySystemParameters(BaseModel):\n    \"\"\"Collection of all energy system parameters for optimization models.\"\"\"\n\n    model_config = ConfigDict(frozen=True, extra=\"forbid\", arbitrary_types_allowed=True)\n\n    generators: GeneratorParameters | None\n    batteries: BatteryParameters | None\n    loads: LoadParameters | None\n    markets: MarketParameters | None\n    scenarios: ScenarioParameters\n</code></pre>"},{"location":"api/math_model/#generator-parameters","title":"Generator Parameters","text":"<p>Generator parameters for the mathematical optimization model.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.generator_parameters.GeneratorIndex","title":"<code>GeneratorIndex</code>","text":"<p>               Bases: <code>ModelIndex</code></p> <p>Index for generator components in the optimization model.</p> Source code in <code>src/odys/math_model/model_components/parameters/generator_parameters.py</code> <pre><code>class GeneratorIndex(ModelIndex):\n    \"\"\"Index for generator components in the optimization model.\"\"\"\n\n    dimension: ClassVar[ModelDimension] = ModelDimension.Generators\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.generator_parameters.GeneratorParameters","title":"<code>GeneratorParameters</code>","text":"<p>Parameters for generator assets in the energy system model.</p> Source code in <code>src/odys/math_model/model_components/parameters/generator_parameters.py</code> <pre><code>class GeneratorParameters:\n    \"\"\"Parameters for generator assets in the energy system model.\"\"\"\n\n    def __init__(self, generators: Sequence[PowerGenerator]) -&gt; None:\n        \"\"\"Initialize generator parameters.\n\n        Args:\n            generators: Sequence of power generator objects.\n        \"\"\"\n        self._index = GeneratorIndex(\n            values=tuple(gen.name for gen in generators),\n        )\n        data = {\n            \"nominal_power\": [gen.nominal_power for gen in generators],\n            \"variable_cost\": [gen.variable_cost for gen in generators],\n            \"min_up_time\": [gen.min_up_time for gen in generators],\n            \"min_power\": [gen.min_power for gen in generators],\n            \"startup_cost\": [gen.startup_cost for gen in generators],\n            \"max_ramp_up\": [gen.ramp_up for gen in generators],\n            \"max_ramp_down\": [gen.ramp_down for gen in generators],\n        }\n        dim = self._index.dimension\n        self._dataset = xr.Dataset(\n            {name: (dim, values) for name, values in data.items()},\n            coords=self._index.coordinates,\n        )\n\n    @property\n    def index(self) -&gt; GeneratorIndex:\n        \"\"\"Return the generator index.\"\"\"\n        return self._index\n\n    @property\n    def nominal_power(self) -&gt; xr.DataArray:\n        \"\"\"Return generator nominal power data.\"\"\"\n        return self._dataset[\"nominal_power\"]\n\n    @property\n    def variable_cost(self) -&gt; xr.DataArray:\n        \"\"\"Return generator variable cost data.\"\"\"\n        return self._dataset[\"variable_cost\"]\n\n    @property\n    def min_up_time(self) -&gt; xr.DataArray:\n        \"\"\"Return generator minimum up time data.\"\"\"\n        return self._dataset[\"min_up_time\"]\n\n    @property\n    def min_power(self) -&gt; xr.DataArray:\n        \"\"\"Return generator minimum power data.\"\"\"\n        return self._dataset[\"min_power\"]\n\n    @property\n    def startup_cost(self) -&gt; xr.DataArray:\n        \"\"\"Return generator startup cost data.\"\"\"\n        return self._dataset[\"startup_cost\"]\n\n    @property\n    def max_ramp_up(self) -&gt; xr.DataArray:\n        \"\"\"Return generator maximum ramp up rate data.\"\"\"\n        return self._dataset[\"max_ramp_up\"]\n\n    @property\n    def max_ramp_down(self) -&gt; xr.DataArray:\n        \"\"\"Return generator maximum ramp down rate data.\"\"\"\n        return self._dataset[\"max_ramp_down\"]\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.generator_parameters.GeneratorParameters.index","title":"<code>index</code>  <code>property</code>","text":"<p>Return the generator index.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.generator_parameters.GeneratorParameters.max_ramp_down","title":"<code>max_ramp_down</code>  <code>property</code>","text":"<p>Return generator maximum ramp down rate data.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.generator_parameters.GeneratorParameters.max_ramp_up","title":"<code>max_ramp_up</code>  <code>property</code>","text":"<p>Return generator maximum ramp up rate data.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.generator_parameters.GeneratorParameters.min_power","title":"<code>min_power</code>  <code>property</code>","text":"<p>Return generator minimum power data.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.generator_parameters.GeneratorParameters.min_up_time","title":"<code>min_up_time</code>  <code>property</code>","text":"<p>Return generator minimum up time data.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.generator_parameters.GeneratorParameters.nominal_power","title":"<code>nominal_power</code>  <code>property</code>","text":"<p>Return generator nominal power data.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.generator_parameters.GeneratorParameters.startup_cost","title":"<code>startup_cost</code>  <code>property</code>","text":"<p>Return generator startup cost data.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.generator_parameters.GeneratorParameters.variable_cost","title":"<code>variable_cost</code>  <code>property</code>","text":"<p>Return generator variable cost data.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.generator_parameters.GeneratorParameters.__init__","title":"<code>__init__(generators)</code>","text":"<p>Initialize generator parameters.</p> <p>Parameters:</p> Name Type Description Default <code>generators</code> <code>Sequence[PowerGenerator]</code> <p>Sequence of power generator objects.</p> required Source code in <code>src/odys/math_model/model_components/parameters/generator_parameters.py</code> <pre><code>def __init__(self, generators: Sequence[PowerGenerator]) -&gt; None:\n    \"\"\"Initialize generator parameters.\n\n    Args:\n        generators: Sequence of power generator objects.\n    \"\"\"\n    self._index = GeneratorIndex(\n        values=tuple(gen.name for gen in generators),\n    )\n    data = {\n        \"nominal_power\": [gen.nominal_power for gen in generators],\n        \"variable_cost\": [gen.variable_cost for gen in generators],\n        \"min_up_time\": [gen.min_up_time for gen in generators],\n        \"min_power\": [gen.min_power for gen in generators],\n        \"startup_cost\": [gen.startup_cost for gen in generators],\n        \"max_ramp_up\": [gen.ramp_up for gen in generators],\n        \"max_ramp_down\": [gen.ramp_down for gen in generators],\n    }\n    dim = self._index.dimension\n    self._dataset = xr.Dataset(\n        {name: (dim, values) for name, values in data.items()},\n        coords=self._index.coordinates,\n    )\n</code></pre>"},{"location":"api/math_model/#battery-parameters","title":"Battery Parameters","text":"<p>Battery parameters for the mathematical optimization model.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.battery_parameters.BatteryIndex","title":"<code>BatteryIndex</code>","text":"<p>               Bases: <code>ModelIndex</code></p> <p>Index for battery components in the optimization model.</p> Source code in <code>src/odys/math_model/model_components/parameters/battery_parameters.py</code> <pre><code>class BatteryIndex(ModelIndex):\n    \"\"\"Index for battery components in the optimization model.\"\"\"\n\n    dimension: ClassVar[ModelDimension] = ModelDimension.Batteries\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.battery_parameters.BatteryParameters","title":"<code>BatteryParameters</code>","text":"<p>Parameters for battery assets in the energy system model.</p> Source code in <code>src/odys/math_model/model_components/parameters/battery_parameters.py</code> <pre><code>class BatteryParameters:\n    \"\"\"Parameters for battery assets in the energy system model.\"\"\"\n\n    def __init__(self, batteries: Sequence[Battery]) -&gt; None:\n        \"\"\"Initialize battery parameters.\n\n        Args:\n            batteries: Sequence of battery objects.\n        \"\"\"\n        self._index = BatteryIndex(\n            values=tuple(battery.name for battery in batteries),\n        )\n        data = {\n            \"capacity\": [battery.capacity for battery in batteries],\n            \"max_power\": [battery.max_power for battery in batteries],\n            \"efficiency_charging\": [battery.efficiency_charging for battery in batteries],\n            \"efficiency_discharging\": [battery.efficiency_discharging for battery in batteries],\n            \"soc_start\": [battery.soc_start for battery in batteries],\n            \"soc_end\": [battery.soc_end for battery in batteries],\n            \"soc_min\": [battery.soc_min for battery in batteries],\n            \"soc_max\": [battery.soc_max for battery in batteries],\n        }\n        dim = self._index.dimension\n        self._dataset = xr.Dataset(\n            {name: (dim, values) for name, values in data.items()},\n            coords=self._index.coordinates,\n        )\n\n    @property\n    def index(self) -&gt; BatteryIndex:\n        \"\"\"Return the battery index.\"\"\"\n        return self._index\n\n    @property\n    def capacity(self) -&gt; xr.DataArray:\n        \"\"\"Return battery capacity data.\"\"\"\n        return self._dataset[\"capacity\"]\n\n    @property\n    def max_power(self) -&gt; xr.DataArray:\n        \"\"\"Return battery maximum power data.\"\"\"\n        return self._dataset[\"max_power\"]\n\n    @property\n    def efficiency_charging(self) -&gt; xr.DataArray:\n        \"\"\"Return battery charging efficiency data.\"\"\"\n        return self._dataset[\"efficiency_charging\"]\n\n    @property\n    def efficiency_discharging(self) -&gt; xr.DataArray:\n        \"\"\"Return battery discharging efficiency data.\"\"\"\n        return self._dataset[\"efficiency_discharging\"]\n\n    @property\n    def soc_start(self) -&gt; xr.DataArray:\n        \"\"\"Return battery initial state of charge data.\"\"\"\n        return self._dataset[\"soc_start\"]\n\n    @property\n    def soc_end(self) -&gt; xr.DataArray:\n        \"\"\"Return battery final state of charge data.\"\"\"\n        return self._dataset[\"soc_end\"]\n\n    @property\n    def soc_min(self) -&gt; xr.DataArray:\n        \"\"\"Return battery minimum state of charge data.\"\"\"\n        return self._dataset[\"soc_min\"]\n\n    @property\n    def soc_max(self) -&gt; xr.DataArray:\n        \"\"\"Return battery maximum state of charge data.\"\"\"\n        return self._dataset[\"soc_max\"]\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.battery_parameters.BatteryParameters.capacity","title":"<code>capacity</code>  <code>property</code>","text":"<p>Return battery capacity data.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.battery_parameters.BatteryParameters.efficiency_charging","title":"<code>efficiency_charging</code>  <code>property</code>","text":"<p>Return battery charging efficiency data.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.battery_parameters.BatteryParameters.efficiency_discharging","title":"<code>efficiency_discharging</code>  <code>property</code>","text":"<p>Return battery discharging efficiency data.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.battery_parameters.BatteryParameters.index","title":"<code>index</code>  <code>property</code>","text":"<p>Return the battery index.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.battery_parameters.BatteryParameters.max_power","title":"<code>max_power</code>  <code>property</code>","text":"<p>Return battery maximum power data.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.battery_parameters.BatteryParameters.soc_end","title":"<code>soc_end</code>  <code>property</code>","text":"<p>Return battery final state of charge data.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.battery_parameters.BatteryParameters.soc_max","title":"<code>soc_max</code>  <code>property</code>","text":"<p>Return battery maximum state of charge data.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.battery_parameters.BatteryParameters.soc_min","title":"<code>soc_min</code>  <code>property</code>","text":"<p>Return battery minimum state of charge data.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.battery_parameters.BatteryParameters.soc_start","title":"<code>soc_start</code>  <code>property</code>","text":"<p>Return battery initial state of charge data.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.battery_parameters.BatteryParameters.__init__","title":"<code>__init__(batteries)</code>","text":"<p>Initialize battery parameters.</p> <p>Parameters:</p> Name Type Description Default <code>batteries</code> <code>Sequence[Battery]</code> <p>Sequence of battery objects.</p> required Source code in <code>src/odys/math_model/model_components/parameters/battery_parameters.py</code> <pre><code>def __init__(self, batteries: Sequence[Battery]) -&gt; None:\n    \"\"\"Initialize battery parameters.\n\n    Args:\n        batteries: Sequence of battery objects.\n    \"\"\"\n    self._index = BatteryIndex(\n        values=tuple(battery.name for battery in batteries),\n    )\n    data = {\n        \"capacity\": [battery.capacity for battery in batteries],\n        \"max_power\": [battery.max_power for battery in batteries],\n        \"efficiency_charging\": [battery.efficiency_charging for battery in batteries],\n        \"efficiency_discharging\": [battery.efficiency_discharging for battery in batteries],\n        \"soc_start\": [battery.soc_start for battery in batteries],\n        \"soc_end\": [battery.soc_end for battery in batteries],\n        \"soc_min\": [battery.soc_min for battery in batteries],\n        \"soc_max\": [battery.soc_max for battery in batteries],\n    }\n    dim = self._index.dimension\n    self._dataset = xr.Dataset(\n        {name: (dim, values) for name, values in data.items()},\n        coords=self._index.coordinates,\n    )\n</code></pre>"},{"location":"api/math_model/#load-parameters","title":"Load Parameters","text":"<p>Load parameters for the mathematical optimization model.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.load_parameters.LoadIndex","title":"<code>LoadIndex</code>","text":"<p>               Bases: <code>ModelIndex</code></p> <p>Index for load components in the optimization model.</p> Source code in <code>src/odys/math_model/model_components/parameters/load_parameters.py</code> <pre><code>class LoadIndex(ModelIndex):\n    \"\"\"Index for load components in the optimization model.\"\"\"\n\n    dimension: ClassVar[ModelDimension] = ModelDimension.Loads\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.load_parameters.LoadParameters","title":"<code>LoadParameters</code>","text":"<p>Parameters for load assets in the energy system model.</p> Source code in <code>src/odys/math_model/model_components/parameters/load_parameters.py</code> <pre><code>class LoadParameters:\n    \"\"\"Parameters for load assets in the energy system model.\"\"\"\n\n    def __init__(self, loads: Sequence[Load]) -&gt; None:\n        \"\"\"Initialize load parameters.\n\n        Args:\n            loads: Sequence of load objects.\n        \"\"\"\n        self._loads = loads\n        self._index = LoadIndex(\n            values=tuple(gen.name for gen in self._loads),\n        )\n\n    @property\n    def index(self) -&gt; LoadIndex:\n        \"\"\"Return the load index.\"\"\"\n        return self._index\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.load_parameters.LoadParameters.index","title":"<code>index</code>  <code>property</code>","text":"<p>Return the load index.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.load_parameters.LoadParameters.__init__","title":"<code>__init__(loads)</code>","text":"<p>Initialize load parameters.</p> <p>Parameters:</p> Name Type Description Default <code>loads</code> <code>Sequence[Load]</code> <p>Sequence of load objects.</p> required Source code in <code>src/odys/math_model/model_components/parameters/load_parameters.py</code> <pre><code>def __init__(self, loads: Sequence[Load]) -&gt; None:\n    \"\"\"Initialize load parameters.\n\n    Args:\n        loads: Sequence of load objects.\n    \"\"\"\n    self._loads = loads\n    self._index = LoadIndex(\n        values=tuple(gen.name for gen in self._loads),\n    )\n</code></pre>"},{"location":"api/math_model/#market-parameters","title":"Market Parameters","text":"<p>Market parameters for the mathematical optimization model.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.market_parameters.MarketIndex","title":"<code>MarketIndex</code>","text":"<p>               Bases: <code>ModelIndex</code></p> <p>Index for market components in the optimization model.</p> Source code in <code>src/odys/math_model/model_components/parameters/market_parameters.py</code> <pre><code>class MarketIndex(ModelIndex):\n    \"\"\"Index for market components in the optimization model.\"\"\"\n\n    dimension: ClassVar[ModelDimension] = ModelDimension.Markets\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.market_parameters.MarketParameters","title":"<code>MarketParameters</code>","text":"<p>Parameters for energy market components in the energy system model.</p> Source code in <code>src/odys/math_model/model_components/parameters/market_parameters.py</code> <pre><code>class MarketParameters:\n    \"\"\"Parameters for energy market components in the energy system model.\"\"\"\n\n    def __init__(self, markets: Sequence[EnergyMarket]) -&gt; None:\n        \"\"\"Initialize market parameters.\n\n        Args:\n            markets: Sequence of energy market objects.\n        \"\"\"\n        self._index = MarketIndex(values=tuple(market.name for market in markets))\n        data = {\n            \"max_volume\": [market.max_trading_volume_per_step for market in markets],\n            \"stage_fixed\": [market.stage_fixed for market in markets],\n            \"trade_direction\": [market.trade_direction for market in markets],\n        }\n        dim = self._index.dimension\n        self._dataset = xr.Dataset(\n            {name: (dim, values) for name, values in data.items()},\n            coords=self._index.coordinates,\n        )\n\n    @property\n    def index(self) -&gt; MarketIndex:\n        \"\"\"Return the market index.\"\"\"\n        return self._index\n\n    @property\n    def max_volume(self) -&gt; xr.DataArray:\n        \"\"\"Return maximum trading volume per time step.\"\"\"\n        return self._dataset[\"max_volume\"]\n\n    @property\n    def stage_fixed(self) -&gt; xr.DataArray:\n        \"\"\"Return whether each market's variables are fixed across scenarios.\"\"\"\n        return self._dataset[\"stage_fixed\"]\n\n    @property\n    def trade_direction(self) -&gt; xr.DataArray:\n        \"\"\"Return the allowed trade direction (buy, sell, or both) per market.\"\"\"\n        return self._dataset[\"trade_direction\"]\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.market_parameters.MarketParameters.index","title":"<code>index</code>  <code>property</code>","text":"<p>Return the market index.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.market_parameters.MarketParameters.max_volume","title":"<code>max_volume</code>  <code>property</code>","text":"<p>Return maximum trading volume per time step.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.market_parameters.MarketParameters.stage_fixed","title":"<code>stage_fixed</code>  <code>property</code>","text":"<p>Return whether each market's variables are fixed across scenarios.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.market_parameters.MarketParameters.trade_direction","title":"<code>trade_direction</code>  <code>property</code>","text":"<p>Return the allowed trade direction (buy, sell, or both) per market.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.market_parameters.MarketParameters.__init__","title":"<code>__init__(markets)</code>","text":"<p>Initialize market parameters.</p> <p>Parameters:</p> Name Type Description Default <code>markets</code> <code>Sequence[EnergyMarket]</code> <p>Sequence of energy market objects.</p> required Source code in <code>src/odys/math_model/model_components/parameters/market_parameters.py</code> <pre><code>def __init__(self, markets: Sequence[EnergyMarket]) -&gt; None:\n    \"\"\"Initialize market parameters.\n\n    Args:\n        markets: Sequence of energy market objects.\n    \"\"\"\n    self._index = MarketIndex(values=tuple(market.name for market in markets))\n    data = {\n        \"max_volume\": [market.max_trading_volume_per_step for market in markets],\n        \"stage_fixed\": [market.stage_fixed for market in markets],\n        \"trade_direction\": [market.trade_direction for market in markets],\n    }\n    dim = self._index.dimension\n    self._dataset = xr.Dataset(\n        {name: (dim, values) for name, values in data.items()},\n        coords=self._index.coordinates,\n    )\n</code></pre>"},{"location":"api/math_model/#scenario-parameters","title":"Scenario Parameters","text":"<p>Scenario parameters for the mathematical optimization model.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.scenario_parameters.ScenarioIndex","title":"<code>ScenarioIndex</code>","text":"<p>               Bases: <code>ModelIndex</code></p> <p>Index for scenario components in the optimization model.</p> Source code in <code>src/odys/math_model/model_components/parameters/scenario_parameters.py</code> <pre><code>class ScenarioIndex(ModelIndex):\n    \"\"\"Index for scenario components in the optimization model.\"\"\"\n\n    dimension: ClassVar[ModelDimension] = ModelDimension.Scenarios\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.scenario_parameters.ScenarioParameters","title":"<code>ScenarioParameters</code>","text":"<p>Parameters for scenarios in the energy system model.</p> Source code in <code>src/odys/math_model/model_components/parameters/scenario_parameters.py</code> <pre><code>class ScenarioParameters:\n    \"\"\"Parameters for scenarios in the energy system model.\"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        number_of_timesteps: int,\n        scenarios: Sequence[StochasticScenario],\n        generators_index: GeneratorIndex | None,\n        batteries_index: BatteryIndex | None,\n        markets_index: MarketIndex | None,\n        loads_index: LoadIndex | None,\n    ) -&gt; None:\n        \"\"\"Initialize scenario parameters.\n\n        Args:\n            number_of_timesteps: Number of time steps in the scenarios.\n            scenarios: Sequence of stochastic scenario objects.\n            generators_index: Optional generator index.\n            batteries_index: Optional battery index.\n            markets_index: Optional market index.\n            loads_index: Optional load index.\n        \"\"\"\n        self._number_of_timesteps = number_of_timesteps\n        self._scenarios = scenarios\n        self._generators_index = generators_index\n        self._batteries_index = batteries_index\n        self._markets_index = markets_index\n        self._loads_index = loads_index\n        self._time_index = TimeIndex(values=tuple(str(time_step) for time_step in range(number_of_timesteps)))\n        self._scenario_index = ScenarioIndex(values=tuple(scenario.name for scenario in self._scenarios))\n\n    @property\n    def time_index(self) -&gt; TimeIndex:\n        \"\"\"Return the time index.\"\"\"\n        return self._time_index\n\n    @property\n    def scenario_index(self) -&gt; ScenarioIndex:\n        \"\"\"Return the scenario index.\"\"\"\n        return self._scenario_index\n\n    @property\n    def load_profiles(self) -&gt; xr.DataArray | None:\n        \"\"\"Return load profiles across scenarios and time.\"\"\"\n        if self._loads_index is None:\n            return None\n        all_load_profiles = []\n        for scenario in self._scenarios:\n            scenario_load_profiles_mapping = scenario.load_profiles or {}\n            scenario_load_profiles_array = [\n                scenario_load_profiles_mapping.get(load_name) for load_name in self._loads_index.values\n            ]\n            all_load_profiles.append(scenario_load_profiles_array)\n\n        return xr.DataArray(\n            data=all_load_profiles,\n            coords=self._scenario_index.coordinates | self._loads_index.coordinates | self._time_index.coordinates,\n        )\n\n    @property\n    def market_prices(self) -&gt; xr.DataArray | None:\n        \"\"\"Return market prices across scenarios and time.\"\"\"\n        if self._markets_index is None:\n            return None\n        all_market_prices = []\n        for scenario in self._scenarios:\n            scenario_market_prices_mapping = scenario.market_prices or {}\n            scenario_market_prices_array = [\n                scenario_market_prices_mapping.get(market_name) for market_name in self._markets_index.values\n            ]\n            all_market_prices.append(scenario_market_prices_array)\n\n        return xr.DataArray(\n            data=all_market_prices,\n            coords=self._scenario_index.coordinates | self._markets_index.coordinates | self._time_index.coordinates,\n        )\n\n    @property\n    def available_capacity_profiles(self) -&gt; xr.DataArray | None:\n        \"\"\"Return available capacity profiles for generators across scenarios and time.\"\"\"\n        if self._generators_index is None:\n            return None\n        all_capacity_profiles = []\n\n        for scenario in self._scenarios:\n            profiles = scenario.available_capacity_profiles or {}\n            scenario_complete_capacity_profiles = [\n                profiles.get(gen_name, [np.inf] * self._number_of_timesteps)\n                for gen_name in self._generators_index.values\n            ]\n            all_capacity_profiles.append(scenario_complete_capacity_profiles)\n\n        return xr.DataArray(\n            data=all_capacity_profiles,\n            coords=self._scenario_index.coordinates | self._generators_index.coordinates | self._time_index.coordinates,\n        )\n\n    @property\n    def scenario_probabilities(self) -&gt; xr.DataArray:\n        \"\"\"Returns scenario probabilities as xarray DataArray.\"\"\"\n        return xr.DataArray(\n            data=[scenario.probability for scenario in self._scenarios],\n            coords=self._scenario_index.coordinates,\n        )\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.scenario_parameters.ScenarioParameters.available_capacity_profiles","title":"<code>available_capacity_profiles</code>  <code>property</code>","text":"<p>Return available capacity profiles for generators across scenarios and time.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.scenario_parameters.ScenarioParameters.load_profiles","title":"<code>load_profiles</code>  <code>property</code>","text":"<p>Return load profiles across scenarios and time.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.scenario_parameters.ScenarioParameters.market_prices","title":"<code>market_prices</code>  <code>property</code>","text":"<p>Return market prices across scenarios and time.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.scenario_parameters.ScenarioParameters.scenario_index","title":"<code>scenario_index</code>  <code>property</code>","text":"<p>Return the scenario index.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.scenario_parameters.ScenarioParameters.scenario_probabilities","title":"<code>scenario_probabilities</code>  <code>property</code>","text":"<p>Returns scenario probabilities as xarray DataArray.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.scenario_parameters.ScenarioParameters.time_index","title":"<code>time_index</code>  <code>property</code>","text":"<p>Return the time index.</p>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.scenario_parameters.ScenarioParameters.__init__","title":"<code>__init__(number_of_timesteps, scenarios, generators_index, batteries_index, markets_index, loads_index)</code>","text":"<p>Initialize scenario parameters.</p> <p>Parameters:</p> Name Type Description Default <code>number_of_timesteps</code> <code>int</code> <p>Number of time steps in the scenarios.</p> required <code>scenarios</code> <code>Sequence[StochasticScenario]</code> <p>Sequence of stochastic scenario objects.</p> required <code>generators_index</code> <code>GeneratorIndex | None</code> <p>Optional generator index.</p> required <code>batteries_index</code> <code>BatteryIndex | None</code> <p>Optional battery index.</p> required <code>markets_index</code> <code>MarketIndex | None</code> <p>Optional market index.</p> required <code>loads_index</code> <code>LoadIndex | None</code> <p>Optional load index.</p> required Source code in <code>src/odys/math_model/model_components/parameters/scenario_parameters.py</code> <pre><code>def __init__(  # noqa: PLR0913\n    self,\n    number_of_timesteps: int,\n    scenarios: Sequence[StochasticScenario],\n    generators_index: GeneratorIndex | None,\n    batteries_index: BatteryIndex | None,\n    markets_index: MarketIndex | None,\n    loads_index: LoadIndex | None,\n) -&gt; None:\n    \"\"\"Initialize scenario parameters.\n\n    Args:\n        number_of_timesteps: Number of time steps in the scenarios.\n        scenarios: Sequence of stochastic scenario objects.\n        generators_index: Optional generator index.\n        batteries_index: Optional battery index.\n        markets_index: Optional market index.\n        loads_index: Optional load index.\n    \"\"\"\n    self._number_of_timesteps = number_of_timesteps\n    self._scenarios = scenarios\n    self._generators_index = generators_index\n    self._batteries_index = batteries_index\n    self._markets_index = markets_index\n    self._loads_index = loads_index\n    self._time_index = TimeIndex(values=tuple(str(time_step) for time_step in range(number_of_timesteps)))\n    self._scenario_index = ScenarioIndex(values=tuple(scenario.name for scenario in self._scenarios))\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.parameters.scenario_parameters.TimeIndex","title":"<code>TimeIndex</code>","text":"<p>               Bases: <code>ModelIndex</code></p> <p>Index for time components in the optimization model.</p> Source code in <code>src/odys/math_model/model_components/parameters/scenario_parameters.py</code> <pre><code>class TimeIndex(ModelIndex):\n    \"\"\"Index for time components in the optimization model.\"\"\"\n\n    dimension: ClassVar[ModelDimension] = ModelDimension.Time\n</code></pre>"},{"location":"api/math_model/#linopy-converter","title":"Linopy Converter","text":"<p>Utilities for converting model variables into linopy-compatible parameters.</p>"},{"location":"api/math_model/#odys.math_model.model_components.linopy_converter.LinopyVariableParameters","title":"<code>LinopyVariableParameters</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters needed to add a variable to a linopy model.</p> Source code in <code>src/odys/math_model/model_components/linopy_converter.py</code> <pre><code>class LinopyVariableParameters(BaseModel):\n    \"\"\"Parameters needed to add a variable to a linopy model.\"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    name: str\n    coords: Mapping[str, list[str]]\n    dims: Sequence[str]\n    lower: np.ndarray | float\n    binary: bool\n</code></pre>"},{"location":"api/math_model/#odys.math_model.model_components.linopy_converter.get_variable_lower_bound","title":"<code>get_variable_lower_bound(indeces, lower_bound_type, *, is_binary)</code>","text":"<p>Calculate lower bounds for a variable.</p> <p>Parameters:</p> Name Type Description Default <code>indeces</code> <code>list[ModelIndex]</code> <p>List of dimension sets for the variable</p> required <code>lower_bound_type</code> <code>BoundType</code> <p>Type of lower bound</p> required <code>is_binary</code> <code>bool</code> <p>Whether the variable is binary</p> required <p>Returns:</p> Type Description <code>ndarray | float</code> <p>Lower bound value or array</p> Source code in <code>src/odys/math_model/model_components/linopy_converter.py</code> <pre><code>def get_variable_lower_bound(\n    indeces: list[ModelIndex],\n    lower_bound_type: BoundType,\n    *,\n    is_binary: bool,\n) -&gt; np.ndarray | float:\n    \"\"\"Calculate lower bounds for a variable.\n\n    Args:\n        indeces: List of dimension sets for the variable\n        lower_bound_type: Type of lower bound\n        is_binary: Whether the variable is binary\n\n    Returns:\n        Lower bound value or array\n    \"\"\"\n    if is_binary:\n        return -np.inf  # Required by linopy.add_variable when variable is binary\n\n    shape = tuple(len(dim_set.values) for dim_set in indeces)\n\n    if lower_bound_type == BoundType.UNBOUNDED:\n        return np.full(shape, -np.inf, dtype=float)\n    return np.full(shape, 0, dtype=float)\n</code></pre>"},{"location":"api/optimization/","title":"Optimization API","text":""},{"location":"api/optimization/#optimizationresults","title":"OptimizationResults","text":"<p>Optimization results handling for energy system models.</p> <p>This module provides classes for handling and analyzing optimization results from energy system models.</p>"},{"location":"api/optimization/#odys.optimization.optimization_results.OptimizationResults","title":"<code>OptimizationResults</code>","text":"<p>Container for optimization results and metadata.</p> <p>This class wraps the solver results and provides convenient access to solution data, solver status, and termination conditions.</p> Source code in <code>src/odys/optimization/optimization_results.py</code> <pre><code>class OptimizationResults:\n    \"\"\"Container for optimization results and metadata.\n\n    This class wraps the solver results and provides convenient access\n    to solution data, solver status, and termination conditions.\n    \"\"\"\n\n    def __init__(\n        self,\n        solver_status: SolverStatus,\n        termination_condition: TerminationCondition,\n        milp_model: EnergyMILPModel,\n    ) -&gt; None:\n        \"\"\"Initialize the optimization results object.\n\n        Args:\n            solver_status: Solving status\n            termination_condition: Termination condition\n            milp_model: Solved EnergyMILPModel Model\n        \"\"\"\n        self._solver_status = solver_status\n        self._termination_condition = termination_condition\n        self._milp_model = milp_model\n\n    @cached_property\n    def solver_status(self) -&gt; str:\n        \"\"\"Get the solver status.\n\n        Returns:\n            The solver status indicating whether the solve was successful.\n\n        \"\"\"\n        return self._solver_status.value\n\n    @cached_property\n    def termination_condition(self) -&gt; str:\n        \"\"\"Get the termination condition.\n\n        Returns:\n            The termination condition indicating how the solver finished.\n\n        \"\"\"\n        return self._termination_condition.value\n\n    @cached_property\n    def _solution(self) -&gt; xr.Dataset:\n        self._validate_terminated_successfully()\n        return self._milp_model.linopy_model.solution\n\n    def to_dataframe(self) -&gt; pd.DataFrame:\n        \"\"\"Convert optimization results to a pandas DataFrame.\n\n        Returns:\n            DataFrame containing all solution variables with units, variables,\n            and time periods as multi-level index columns.\n        \"\"\"\n        dfs = []\n        for variable in ModelVariable:\n            variable_name = variable.var_name\n            # Skip if there is this variable is not populated (eg skip battery varialbes if no batteries in the system)\n            if variable_name not in self._milp_model.linopy_model.variables.labels:\n                continue\n            var_solution = self._solution[variable_name]\n            df = (\n                var_solution\n                .to_series()\n                .reset_index()\n                .rename(columns={variable.asset_dimension: \"unit\", variable_name: \"value\"})\n                .assign(variable=variable_name)\n            )\n            dfs.append(df)\n\n        return (\n            pd\n            .concat(dfs, ignore_index=True)\n            .set_index([\n                ModelDimension.Scenarios,\n                \"unit\",\n                \"variable\",\n                ModelDimension.Time,\n            ])\n            .sort_index()\n            .pipe(self._drop_single_scenario_level)\n        )\n\n    def _drop_single_scenario_level(self, df: pd.DataFrame) -&gt; pd.DataFrame:\n        scenario_values = df.index.get_level_values(ModelDimension.Scenarios).to_numpy()\n        if (scenario_values == scenario_values[0]).all():\n            return df.droplevel(ModelDimension.Scenarios)\n        return df\n\n    def _validate_terminated_successfully(self) -&gt; None:\n        if self._solver_status != SolverStatus.ok:\n            msg = f\"No solution available. Optimization Termination Condition: {self.termination_condition}.\"\n            raise ValueError(msg)\n\n    @cached_property\n    def batteries(self) -&gt; BatteryResults:\n        \"\"\"Get battery results.\"\"\"\n        self._validate_terminated_successfully()\n        if self._milp_model.parameters.batteries is None:\n            msg = \"This model does not contain battery results\"\n            raise ValueError(msg)\n        return BatteryResults(\n            net_power=self._get_variable_results(ModelVariable.BATTERY_POWER_NET),\n            state_of_charge=self._get_variable_results(ModelVariable.BATTERY_SOC),\n        )\n\n    @cached_property\n    def markets(self) -&gt; MarketResults:\n        \"\"\"Get market results.\"\"\"\n        self._validate_terminated_successfully()\n        if self._milp_model.parameters.markets is None:\n            msg = \"This model does not contain market results\"\n            raise ValueError(msg)\n        return MarketResults(\n            sell_volume=self._get_variable_results(ModelVariable.MARKET_SELL),\n            buy_volume=self._get_variable_results(ModelVariable.MARKET_BUY),\n        )\n\n    @cached_property\n    def generators(self) -&gt; GeneratorResults:\n        \"\"\"Get generator results.\"\"\"\n        self._validate_terminated_successfully()\n        if self._milp_model.parameters.generators is None:\n            msg = \"This model does not contain generator results\"\n            raise ValueError(msg)\n\n        return GeneratorResults(\n            power=self._get_variable_results(ModelVariable.GENERATOR_POWER),\n            status=self._get_variable_results(ModelVariable.GENERATOR_STATUS),\n            startup=self._get_variable_results(ModelVariable.GENERATOR_STARTUP),\n            shutdown=self._get_variable_results(ModelVariable.GENERATOR_SHUTDOWN),\n        )\n\n    def _get_variable_results(self, variable: ModelVariable) -&gt; pd.DataFrame:\n        var_timeseries = self._solution[variable.var_name].to_series()\n        return var_timeseries.unstack().pipe(self._drop_single_scenario_level)  # noqa: PD010\n</code></pre>"},{"location":"api/optimization/#odys.optimization.optimization_results.OptimizationResults.batteries","title":"<code>batteries</code>  <code>cached</code> <code>property</code>","text":"<p>Get battery results.</p>"},{"location":"api/optimization/#odys.optimization.optimization_results.OptimizationResults.generators","title":"<code>generators</code>  <code>cached</code> <code>property</code>","text":"<p>Get generator results.</p>"},{"location":"api/optimization/#odys.optimization.optimization_results.OptimizationResults.markets","title":"<code>markets</code>  <code>cached</code> <code>property</code>","text":"<p>Get market results.</p>"},{"location":"api/optimization/#odys.optimization.optimization_results.OptimizationResults.solver_status","title":"<code>solver_status</code>  <code>cached</code> <code>property</code>","text":"<p>Get the solver status.</p> <p>Returns:</p> Type Description <code>str</code> <p>The solver status indicating whether the solve was successful.</p>"},{"location":"api/optimization/#odys.optimization.optimization_results.OptimizationResults.termination_condition","title":"<code>termination_condition</code>  <code>cached</code> <code>property</code>","text":"<p>Get the termination condition.</p> <p>Returns:</p> Type Description <code>str</code> <p>The termination condition indicating how the solver finished.</p>"},{"location":"api/optimization/#odys.optimization.optimization_results.OptimizationResults.__init__","title":"<code>__init__(solver_status, termination_condition, milp_model)</code>","text":"<p>Initialize the optimization results object.</p> <p>Parameters:</p> Name Type Description Default <code>solver_status</code> <code>SolverStatus</code> <p>Solving status</p> required <code>termination_condition</code> <code>TerminationCondition</code> <p>Termination condition</p> required <code>milp_model</code> <code>EnergyMILPModel</code> <p>Solved EnergyMILPModel Model</p> required Source code in <code>src/odys/optimization/optimization_results.py</code> <pre><code>def __init__(\n    self,\n    solver_status: SolverStatus,\n    termination_condition: TerminationCondition,\n    milp_model: EnergyMILPModel,\n) -&gt; None:\n    \"\"\"Initialize the optimization results object.\n\n    Args:\n        solver_status: Solving status\n        termination_condition: Termination condition\n        milp_model: Solved EnergyMILPModel Model\n    \"\"\"\n    self._solver_status = solver_status\n    self._termination_condition = termination_condition\n    self._milp_model = milp_model\n</code></pre>"},{"location":"api/optimization/#odys.optimization.optimization_results.OptimizationResults.to_dataframe","title":"<code>to_dataframe()</code>","text":"<p>Convert optimization results to a pandas DataFrame.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing all solution variables with units, variables,</p> <code>DataFrame</code> <p>and time periods as multi-level index columns.</p> Source code in <code>src/odys/optimization/optimization_results.py</code> <pre><code>def to_dataframe(self) -&gt; pd.DataFrame:\n    \"\"\"Convert optimization results to a pandas DataFrame.\n\n    Returns:\n        DataFrame containing all solution variables with units, variables,\n        and time periods as multi-level index columns.\n    \"\"\"\n    dfs = []\n    for variable in ModelVariable:\n        variable_name = variable.var_name\n        # Skip if there is this variable is not populated (eg skip battery varialbes if no batteries in the system)\n        if variable_name not in self._milp_model.linopy_model.variables.labels:\n            continue\n        var_solution = self._solution[variable_name]\n        df = (\n            var_solution\n            .to_series()\n            .reset_index()\n            .rename(columns={variable.asset_dimension: \"unit\", variable_name: \"value\"})\n            .assign(variable=variable_name)\n        )\n        dfs.append(df)\n\n    return (\n        pd\n        .concat(dfs, ignore_index=True)\n        .set_index([\n            ModelDimension.Scenarios,\n            \"unit\",\n            \"variable\",\n            ModelDimension.Time,\n        ])\n        .sort_index()\n        .pipe(self._drop_single_scenario_level)\n    )\n</code></pre>"},{"location":"api/optimization/#result-containers","title":"Result Containers","text":"<p>Containers for storing per-asset optimization results.</p>"},{"location":"api/optimization/#odys.optimization.result_containers.BatteryResults","title":"<code>BatteryResults</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Class to store battery results.</p> Source code in <code>src/odys/optimization/result_containers.py</code> <pre><code>class BatteryResults(BaseModel):\n    \"\"\"Class to store battery results.\"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    net_power: pd.DataFrame\n    state_of_charge: pd.DataFrame\n</code></pre>"},{"location":"api/optimization/#odys.optimization.result_containers.GeneratorResults","title":"<code>GeneratorResults</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Class to store generator results.</p> Source code in <code>src/odys/optimization/result_containers.py</code> <pre><code>class GeneratorResults(BaseModel):\n    \"\"\"Class to store generator results.\"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    power: pd.DataFrame\n    status: pd.DataFrame\n    startup: pd.DataFrame\n    shutdown: pd.DataFrame\n</code></pre>"},{"location":"api/optimization/#odys.optimization.result_containers.MarketResults","title":"<code>MarketResults</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Class to store market results.</p> Source code in <code>src/odys/optimization/result_containers.py</code> <pre><code>class MarketResults(BaseModel):\n    \"\"\"Class to store market results.\"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    sell_volume: pd.DataFrame\n    buy_volume: pd.DataFrame\n</code></pre>"},{"location":"api/solvers/","title":"Solvers API","text":"<p>The solvers module contains different optimization solver implementations.</p>"},{"location":"api/solvers/#highs-solver","title":"HiGHS Solver","text":"<p>HiGHS solver implementation for energy system optimization.</p> <p>This module provides the HiGHSolver class for solving energy system optimization problems using the HiGHS linear programming solver.</p>"},{"location":"api/solvers/#odys.solvers.highs_solver.optimize_algebraic_model","title":"<code>optimize_algebraic_model(milp_model)</code>","text":"<p>Solve the optimization model using HiGHS.</p> <p>Parameters:</p> Name Type Description Default <code>milp_model</code> <code>EnergyMILPModel</code> <p>The EnergyMILPModel to solve.</p> required <p>Returns:</p> Type Description <code>OptimizationResults</code> <p>OptimizationResults containing the solution and metadata.</p> Source code in <code>src/odys/solvers/highs_solver.py</code> <pre><code>def optimize_algebraic_model(milp_model: EnergyMILPModel) -&gt; OptimizationResults:\n    \"\"\"Solve the optimization model using HiGHS.\n\n    Args:\n        milp_model: The EnergyMILPModel to solve.\n\n    Returns:\n        OptimizationResults containing the solution and metadata.\n\n    \"\"\"\n    solving_status, termination_condition = milp_model.linopy_model.solve(\n        solver_name=\"highs\",\n        explicit_coordinate_names=True,\n        output_flag=False,\n    )\n\n    return OptimizationResults(\n        solver_status=SolverStatus(solving_status),\n        termination_condition=TerminationCondition(termination_condition),\n        milp_model=milp_model,\n    )\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>These examples walk through common odys use cases, from a basic single-scenario dispatch to stochastic optimization with multiple markets.</p> <p>Each example is self-contained -- you can copy-paste it and run it directly.</p> Example What it shows Basic Dispatch Generators + battery meeting a fixed load Stochastic Scenarios Multiple wind scenarios with batteries Stochastic Without Batteries Stochastic dispatch using generators only Markets Selling excess generation into electricity markets Markets + Stochastic Stochastic scenarios with stage-fixed market decisions"},{"location":"examples/#running-the-examples","title":"Running the examples","text":"<p>All examples are available in the <code>examples/</code> directory of the repository. To run one:</p> <pre><code>python examples/example1.py\n</code></pre>"},{"location":"examples/basic_dispatch/","title":"Basic Dispatch","text":"<p>This example shows the core odys workflow: two generators and a battery dispatched to meet a fixed load at minimum cost.</p> <p>Source: <code>examples/example1.py</code></p>"},{"location":"examples/basic_dispatch/#what-it-demonstrates","title":"What it demonstrates","text":"<ul> <li>Setting up generators with different costs and constraints (ramp rates, min up time, min power)</li> <li>Adding a battery with efficiency losses and SOC bounds</li> <li>Using <code>available_capacity_profiles</code> to limit a generator's output over time</li> <li>Reading the optimization results</li> </ul>"},{"location":"examples/basic_dispatch/#the-setup","title":"The setup","text":"<p>We have two generators with different characteristics:</p> <ul> <li>gen1: Cheap (20 $/MWh), 100 MW, with a ramp-down limit and varying available capacity</li> <li>gen2: Expensive (100 $/MWh), 150 MW, with ramp limits, min power, and a 4-step min up time</li> </ul> <p>Plus a battery (200 MW, 100 MWh) that starts full and must end at 50% SOC.</p>"},{"location":"examples/basic_dispatch/#code","title":"Code","text":"<pre><code>from datetime import timedelta\n\nfrom odys.energy_system import EnergySystem\nfrom odys.energy_system_models.assets.generator import PowerGenerator\nfrom odys.energy_system_models.assets.load import Load, LoadType\nfrom odys.energy_system_models.assets.portfolio import AssetPortfolio\nfrom odys.energy_system_models.assets.storage import Battery\nfrom odys.energy_system_models.scenarios import Scenario\n\ngenerator_1 = PowerGenerator(\n    name=\"gen1\",\n    nominal_power=100.0,\n    variable_cost=20.0,\n    min_up_time=1,\n    ramp_down=100,\n)\ngenerator_2 = PowerGenerator(\n    name=\"gen2\",\n    nominal_power=150.0,\n    variable_cost=100.0,\n    min_up_time=4,\n    min_power=30,\n    startup_cost=0,\n    ramp_up=140,\n    ramp_down=100,\n)\nbattery_1 = Battery(\n    name=\"battery1\",\n    max_power=200.0,\n    capacity=100.0,\n    efficiency_charging=0.9,\n    efficiency_discharging=0.8,\n    soc_start=1.0,\n    soc_end=0.5,\n    soc_min=0.1,\n)\n\nportfolio = AssetPortfolio()\nportfolio.add_asset(generator_1)\nportfolio.add_asset(generator_2)\nportfolio.add_asset(battery_1)\nportfolio.add_asset(Load(name=\"load\", type=LoadType.Fixed))\n\nenergy_system = EnergySystem(\n    portfolio=portfolio,\n    scenarios=Scenario(\n        available_capacity_profiles={\n            \"gen1\": [100, 100, 100, 50, 50, 50, 50],\n        },\n        load_profiles={\"load\": [300, 75, 300, 50, 100, 120, 125]},\n    ),\n    timestep=timedelta(minutes=30),\n    number_of_steps=7,\n    power_unit=\"MW\",\n)\n\nresult = energy_system.optimize()\n</code></pre>"},{"location":"examples/basic_dispatch/#reading-the-results","title":"Reading the results","text":"<pre><code># Check that the solver found an optimal solution\nprint(result.solver_status)         # \"ok\"\nprint(result.termination_condition)  # \"optimal\"\n\n# Generator dispatch\nprint(result.generators.power)\n\n# Battery charge/discharge\nprint(result.batteries.net_power)\n\n# Everything in one DataFrame\nprint(result.to_dataframe)\n</code></pre>"},{"location":"examples/basic_dispatch/#what-to-look-for","title":"What to look for","text":"<ul> <li>gen1 is dispatched first because it's cheaper, but it's capped by <code>available_capacity_profiles</code> in later timesteps.</li> <li>gen2 kicks in when gen1 can't cover the load, but once it's on, it stays on for at least 4 steps (<code>min_up_time=4</code>).</li> <li>The battery discharges when demand is high and charges when demand is low, respecting its SOC constraints.</li> </ul>"},{"location":"examples/markets/","title":"Markets","text":"<p>This example shows how to include electricity markets in a deterministic dispatch problem. Generators can sell excess power into markets for additional revenue.</p> <p>Source: <code>examples/example4.py</code></p>"},{"location":"examples/markets/#what-it-demonstrates","title":"What it demonstrates","text":"<ul> <li>Adding multiple <code>EnergyMarket</code> instances with different volume limits</li> <li>Providing <code>market_prices</code> in the scenario</li> <li>How the optimizer decides where to sell excess generation</li> </ul>"},{"location":"examples/markets/#the-setup","title":"The setup","text":"<p>Two generators with different costs, a fixed load, and three electricity markets:</p> <ul> <li>sdac: Day-ahead market (max 150 MW/step)</li> <li>sidc1: Intraday market 1 (max 100 MW/step)</li> <li>sidc2: Intraday market 2 (max 50 MW/step)</li> </ul> <p>Each market has its own price timeseries. The optimizer will dispatch generators to meet the load and then sell any excess into the most profitable market.</p>"},{"location":"examples/markets/#code","title":"Code","text":"<pre><code>from datetime import timedelta\n\nfrom odys.energy_system import EnergySystem\nfrom odys.energy_system_models.assets.generator import PowerGenerator\nfrom odys.energy_system_models.assets.load import Load, LoadType\nfrom odys.energy_system_models.assets.portfolio import AssetPortfolio\nfrom odys.energy_system_models.markets import EnergyMarket\nfrom odys.energy_system_models.scenarios import Scenario\n\ngenerator_1 = PowerGenerator(\n    name=\"gen1\",\n    nominal_power=100.0,\n    variable_cost=20.0,\n    min_up_time=1,\n    ramp_down=100,\n)\ngenerator_2 = PowerGenerator(\n    name=\"gen2\",\n    nominal_power=150.0,\n    variable_cost=100.0,\n    min_up_time=4,\n    min_power=30,\n    startup_cost=0,\n    ramp_up=140,\n    ramp_down=100,\n)\n\nportfolio = AssetPortfolio()\nportfolio.add_asset(generator_1)\nportfolio.add_asset(generator_2)\nportfolio.add_asset(Load(name=\"load\", type=LoadType.Fixed))\n\nenergy_system = EnergySystem(\n    portfolio=portfolio,\n    markets=(\n        EnergyMarket(name=\"sdac\", max_trading_volume_per_step=150),\n        EnergyMarket(name=\"sidc1\", max_trading_volume_per_step=100),\n        EnergyMarket(name=\"sidc2\", max_trading_volume_per_step=50),\n    ),\n    scenarios=Scenario(\n        available_capacity_profiles={\n            \"gen1\": [100, 100, 100, 50, 50, 50, 50],\n        },\n        load_profiles={\"load\": [200, 75, 200, 50, 100, 120, 125]},\n        market_prices={\n            \"sdac\": [150, 150, 150, 150, 150, 150, 150],\n            \"sidc1\": [200, 200, 200, 175, 100, 100, 100],\n            \"sidc2\": [190, 150, 150, 175, 100, 100, 100],\n        },\n    ),\n    timestep=timedelta(minutes=30),\n    number_of_steps=7,\n    power_unit=\"MW\",\n)\n\nresult = energy_system.optimize()\n</code></pre>"},{"location":"examples/markets/#reading-the-results","title":"Reading the results","text":"<pre><code>print(result.generators.power)     # how much each generator produces\nprint(result.markets.sell_volume)   # how much is sold to each market\nprint(result.to_dataframe)          # everything in one place\n</code></pre>"},{"location":"examples/markets/#what-to-look-for","title":"What to look for","text":"<ul> <li>The optimizer sells excess generation to whichever market pays the most at each timestep.</li> <li>sidc1 has higher prices than sdac in the first few steps, so it gets filled first (up to its volume limit).</li> <li>Generators may produce more than the load requires when market revenue exceeds operating costs.</li> </ul>"},{"location":"examples/markets_stochastic/","title":"Markets + Stochastic","text":"<p>This example combines stochastic scenarios with multiple electricity markets, including stage-fixed decisions. It's the most complete example in the collection.</p> <p>Source: <code>examples/example5.py</code></p>"},{"location":"examples/markets_stochastic/#what-it-demonstrates","title":"What it demonstrates","text":"<ul> <li>Stochastic scenarios with different market prices per scenario</li> <li><code>stage_fixed=True</code> on the day-ahead market (same volumes in all scenarios)</li> <li><code>TradeDirection.BUY</code> to restrict markets to buy-only</li> <li>How the optimizer splits decisions between \"commit now\" and \"adjust later\"</li> </ul>"},{"location":"examples/markets_stochastic/#the-setup","title":"The setup","text":"<p>Two generators, a fixed load, and three buy-only markets:</p> <ul> <li>sdac: Day-ahead market, <code>stage_fixed=True</code> -- bids must be identical across scenarios</li> <li>sidc1: Intraday market 1 -- can adjust per scenario</li> <li>sidc2: Intraday market 2 -- can adjust per scenario</li> </ul> <p>Two scenarios with different price forecasts.</p>"},{"location":"examples/markets_stochastic/#code","title":"Code","text":"<pre><code>from datetime import timedelta\n\nfrom odys.energy_system import EnergySystem\nfrom odys.energy_system_models.assets.generator import PowerGenerator\nfrom odys.energy_system_models.assets.load import Load, LoadType\nfrom odys.energy_system_models.assets.portfolio import AssetPortfolio\nfrom odys.energy_system_models.markets import EnergyMarket, TradeDirection\nfrom odys.energy_system_models.scenarios import StochasticScenario\n\ngenerator_1 = PowerGenerator(\n    name=\"gen1\",\n    nominal_power=100.0,\n    variable_cost=20.0,\n    min_up_time=1,\n    ramp_down=100,\n)\ngenerator_2 = PowerGenerator(\n    name=\"gen2\",\n    nominal_power=150.0,\n    variable_cost=100.0,\n    min_up_time=4,\n    min_power=30,\n    startup_cost=0,\n    ramp_up=140,\n    ramp_down=100,\n)\n\nportfolio = AssetPortfolio()\nportfolio.add_asset(generator_1)\nportfolio.add_asset(generator_2)\nportfolio.add_asset(Load(name=\"load\", type=LoadType.Fixed))\n\nenergy_system = EnergySystem(\n    portfolio=portfolio,\n    markets=(\n        EnergyMarket(\n            name=\"sdac\",\n            max_trading_volume_per_step=150,\n            stage_fixed=True,\n            trade_direction=TradeDirection.BUY,\n        ),\n        EnergyMarket(\n            name=\"sidc1\",\n            max_trading_volume_per_step=100,\n            trade_direction=TradeDirection.BUY,\n        ),\n        EnergyMarket(\n            name=\"sidc2\",\n            max_trading_volume_per_step=50,\n            trade_direction=TradeDirection.BUY,\n        ),\n    ),\n    scenarios=[\n        StochasticScenario(\n            name=\"scenario1\",\n            probability=0.5,\n            available_capacity_profiles={\n                \"gen1\": [100, 100, 100, 50, 50, 50, 50],\n            },\n            load_profiles={\"load\": [200, 75, 200, 50, 100, 120, 125]},\n            market_prices={\n                \"sdac\": [150, 150, 150, 150, 150, 150, 150],\n                \"sidc1\": [200, 200, 200, 175, 100, 100, 100],\n                \"sidc2\": [190, 150, 150, 175, 100, 100, 100],\n            },\n        ),\n        StochasticScenario(\n            name=\"scenario2\",\n            probability=0.5,\n            available_capacity_profiles={\n                \"gen1\": [100, 100, 100, 50, 50, 50, 50],\n            },\n            load_profiles={\"load\": [200, 75, 200, 50, 100, 120, 125]},\n            market_prices={\n                \"sdac\": [210, 210, 210, 185, 100, 100, 100],\n                \"sidc1\": [120, 140, 140, 140, 140, 140, 140],\n                \"sidc2\": [200, 160, 140, 180, 110, 90, 100],\n            },\n        ),\n    ],\n    timestep=timedelta(minutes=30),\n    number_of_steps=7,\n    power_unit=\"MW\",\n)\n\nresult = energy_system.optimize()\n</code></pre>"},{"location":"examples/markets_stochastic/#reading-the-results","title":"Reading the results","text":"<pre><code>print(result.generators.power)     # dispatch per scenario\nprint(result.markets.sell_volume)   # (should be zero -- buy-only markets)\nprint(result.markets.buy_volume)    # volumes bought from each market\nprint(result.to_dataframe)\n</code></pre>"},{"location":"examples/markets_stochastic/#what-to-look-for","title":"What to look for","text":"<ul> <li>The sdac buy volumes are identical in both scenarios because <code>stage_fixed=True</code>. The optimizer picks volumes that work well on average.</li> <li>sidc1 and sidc2 volumes differ between scenarios since the optimizer can react to the realized prices.</li> <li>All markets are buy-only (<code>TradeDirection.BUY</code>), so <code>sell_volume</code> should be zero.</li> <li>Compare the sdac volumes across scenarios -- they're the same, which is the non-anticipativity constraint at work.</li> </ul>"},{"location":"examples/stochastic/","title":"Stochastic Scenarios","text":"<p>This example shows how to optimize across multiple scenarios with different wind outputs, using generators and a battery.</p> <p>Source: <code>examples/example2.py</code></p>"},{"location":"examples/stochastic/#what-it-demonstrates","title":"What it demonstrates","text":"<ul> <li>Defining multiple <code>StochasticScenario</code> instances with probabilities</li> <li>Varying <code>available_capacity_profiles</code> across scenarios (different wind conditions)</li> <li>How the optimizer balances dispatch decisions across uncertain futures</li> </ul>"},{"location":"examples/stochastic/#the-setup","title":"The setup","text":"<p>Two generators:</p> <ul> <li>gen1: A conventional generator (100 MW, 200 $/MWh)</li> <li>wind_farm: A wind generator (150 MW, 100 $/MWh) with variable output</li> </ul> <p>Plus a battery (200 MW, 100 MWh) and a fixed load.</p> <p>We define two equally likely scenarios:</p> <ul> <li>default: Moderate wind availability</li> <li>high_wind: More wind available in the first few timesteps</li> </ul>"},{"location":"examples/stochastic/#code","title":"Code","text":"<pre><code>from datetime import timedelta\n\nfrom odys.energy_system import EnergySystem\nfrom odys.energy_system_models.assets.generator import PowerGenerator\nfrom odys.energy_system_models.assets.load import Load, LoadType\nfrom odys.energy_system_models.assets.portfolio import AssetPortfolio\nfrom odys.energy_system_models.assets.storage import Battery\nfrom odys.energy_system_models.scenarios import StochasticScenario\n\ngenerator_1 = PowerGenerator(\n    name=\"gen1\",\n    nominal_power=100.0,\n    variable_cost=200.0,\n    min_up_time=1,\n    ramp_down=100,\n)\ngenerator_2 = PowerGenerator(\n    name=\"wind_farm\",\n    nominal_power=150.0,\n    variable_cost=100.0,\n)\nbattery_1 = Battery(\n    name=\"battery1\",\n    max_power=200.0,\n    capacity=100,\n    efficiency_charging=0.9,\n    efficiency_discharging=0.8,\n    soc_start=1.0,\n    soc_end=0.5,\n)\nload = Load(name=\"load\", type=LoadType.Fixed)\n\nportfolio = AssetPortfolio()\nportfolio.add_asset(generator_1)\nportfolio.add_asset(generator_2)\nportfolio.add_asset(battery_1)\nportfolio.add_asset(load)\n\nscenarios = [\n    StochasticScenario(\n        name=\"default\",\n        probability=0.5,\n        available_capacity_profiles={\n            \"gen1\": [100, 100, 100, 50, 50, 50, 50],\n            \"wind_farm\": [100, 100, 100, 50, 50, 50, 50],\n        },\n        load_profiles={\n            \"load\": [180, 180, 150, 50, 80, 90, 100],\n        },\n    ),\n    StochasticScenario(\n        name=\"high_wind\",\n        probability=0.5,\n        available_capacity_profiles={\n            \"gen1\": [100, 100, 100, 50, 50, 50, 50],\n            \"wind_farm\": [150, 150, 100, 50, 50, 50, 50],\n        },\n        load_profiles={\n            \"load\": [180, 180, 150, 50, 80, 90, 100],\n        },\n    ),\n]\n\nenergy_system = EnergySystem(\n    portfolio=portfolio,\n    timestep=timedelta(minutes=30),\n    number_of_steps=7,\n    scenarios=scenarios,\n    power_unit=\"MW\",\n)\n\nresult = energy_system.optimize()\n</code></pre>"},{"location":"examples/stochastic/#reading-the-results","title":"Reading the results","text":"<pre><code>print(result.generators.power)      # dispatch per scenario\nprint(result.batteries.net_power)    # battery behavior per scenario\nprint(result.to_dataframe)           # everything combined\n</code></pre> <p>Since we have two scenarios, the results include a scenario dimension. You can compare how the optimizer dispatches differently under each wind condition.</p>"},{"location":"examples/stochastic/#what-to-look-for","title":"What to look for","text":"<ul> <li>The wind_farm is cheaper, so the optimizer uses it first. In the high_wind scenario, it can produce more.</li> <li>gen1 is expensive (200 $/MWh) and only runs when the wind farm and battery can't cover the load.</li> <li>The battery shifts energy across timesteps to minimize total cost, considering both scenarios.</li> </ul>"},{"location":"examples/stochastic_no_batteries/","title":"Stochastic Without Batteries","text":"<p>This example shows stochastic optimization with generators only -- no battery storage.</p> <p>Source: <code>examples/example3.py</code></p>"},{"location":"examples/stochastic_no_batteries/#what-it-demonstrates","title":"What it demonstrates","text":"<ul> <li>Stochastic dispatch without energy storage</li> <li>How asymmetric probabilities (10% vs 90%) affect the optimal solution</li> <li>A simpler system where generators must directly meet demand at each timestep</li> </ul>"},{"location":"examples/stochastic_no_batteries/#the-setup","title":"The setup","text":"<p>Two generators:</p> <ul> <li>gen1: Conventional (100 MW, 200 $/MWh) with a ramp-down limit</li> <li>wind_farm: Wind-based (150 MW, 100 $/MWh) with variable availability</li> </ul> <p>No battery this time -- the generators have to handle everything.</p> <p>Two scenarios with asymmetric probabilities:</p> <ul> <li>low_wind (10%): Moderate wind availability</li> <li>high_wind (90%): More wind in the first few timesteps</li> </ul>"},{"location":"examples/stochastic_no_batteries/#code","title":"Code","text":"<pre><code>from datetime import timedelta\n\nfrom odys.energy_system import EnergySystem\nfrom odys.energy_system_models.assets.generator import PowerGenerator\nfrom odys.energy_system_models.assets.load import Load\nfrom odys.energy_system_models.assets.portfolio import AssetPortfolio\nfrom odys.energy_system_models.scenarios import StochasticScenario\n\ngenerator_1 = PowerGenerator(\n    name=\"gen1\",\n    nominal_power=100.0,\n    variable_cost=200.0,\n    min_up_time=1,\n    ramp_down=100,\n)\ngenerator_2 = PowerGenerator(\n    name=\"wind_farm\",\n    nominal_power=150.0,\n    variable_cost=100.0,\n)\n\nportfolio = AssetPortfolio()\nportfolio.add_asset(generator_1)\nportfolio.add_asset(generator_2)\nportfolio.add_asset(Load(name=\"load\"))\n\nscenarios = [\n    StochasticScenario(\n        name=\"low_wind\",\n        probability=0.1,\n        available_capacity_profiles={\n            \"gen1\": [100, 100, 100, 50, 50, 50, 50],\n            \"wind_farm\": [100, 100, 100, 50, 50, 50, 50],\n        },\n        load_profiles={\n            \"load\": [180, 180, 150, 50, 80, 90, 95],\n        },\n    ),\n    StochasticScenario(\n        name=\"high_wind\",\n        probability=0.9,\n        available_capacity_profiles={\n            \"gen1\": [100, 100, 100, 50, 50, 50, 50],\n            \"wind_farm\": [150, 150, 100, 50, 50, 50, 50],\n        },\n        load_profiles={\n            \"load\": [180, 180, 150, 50, 80, 90, 95],\n        },\n    ),\n]\n\nenergy_system = EnergySystem(\n    portfolio=portfolio,\n    timestep=timedelta(minutes=30),\n    number_of_steps=7,\n    scenarios=scenarios,\n    power_unit=\"MW\",\n)\n\nresult = energy_system.optimize()\n</code></pre>"},{"location":"examples/stochastic_no_batteries/#reading-the-results","title":"Reading the results","text":"<pre><code>print(result.generators.power)\nprint(result.to_dataframe)\n</code></pre>"},{"location":"examples/stochastic_no_batteries/#what-to-look-for","title":"What to look for","text":"<ul> <li>With 90% probability on high wind, the optimizer leans heavily toward the wind scenario.</li> <li>Without a battery, there's no way to shift energy across timesteps -- each step has to balance on its own.</li> <li>Compare this to the Stochastic Scenarios example to see how a battery changes the solution.</li> </ul>"},{"location":"user_guide/asset_portfolio/","title":"AssetPortfolio","text":"<p>An <code>AssetPortfolio</code> is the container that holds all your energy assets. You add generators, batteries, and loads to it, then pass it to the <code>EnergySystem</code>.</p>"},{"location":"user_guide/asset_portfolio/#basic-usage","title":"Basic usage","text":"<pre><code>from odys.energy_system_models.assets.generator import PowerGenerator\nfrom odys.energy_system_models.assets.load import Load\nfrom odys.energy_system_models.assets.portfolio import AssetPortfolio\nfrom odys.energy_system_models.assets.storage import Battery\n\nportfolio = AssetPortfolio()\nportfolio.add_asset(PowerGenerator(name=\"gen\", nominal_power=100.0, variable_cost=50.0))\nportfolio.add_asset(Battery(\n    name=\"bess\", capacity=50.0, max_power=25.0,\n    efficiency_charging=0.95, efficiency_discharging=0.95, soc_start=0.5,\n))\nportfolio.add_asset(Load(name=\"demand\"))\n</code></pre>"},{"location":"user_guide/asset_portfolio/#adding-assets","title":"Adding assets","text":"<p>Use <code>add_asset()</code> to add any <code>EnergyAsset</code> (generators, batteries, loads):</p> <pre><code>portfolio = AssetPortfolio()\nportfolio.add_asset(generator)\nportfolio.add_asset(battery)\nportfolio.add_asset(load)\n</code></pre> <p>Warning</p> <p>Asset names must be unique within a portfolio. Adding two assets with the same <code>name</code> raises a <code>ValueError</code>.</p>"},{"location":"user_guide/asset_portfolio/#accessing-assets","title":"Accessing assets","text":"<p>You can retrieve a specific asset by name:</p> <pre><code>gen = portfolio.get_asset(\"gen\")\n</code></pre> <p>Or get a read-only view of all assets:</p> <pre><code>all_assets = portfolio.assets  # MappingProxyType (read-only dict)\n</code></pre>"},{"location":"user_guide/asset_portfolio/#filtering-by-type","title":"Filtering by type","text":"<p>The portfolio has convenience properties to get assets by type:</p> <pre><code>portfolio.generators  # tuple of all PowerGenerator assets\nportfolio.batteries   # tuple of all Battery assets\nportfolio.loads       # tuple of all Load assets\n</code></pre> <p>These return tuples, so they're safe to iterate over without worrying about accidental modification.</p>"},{"location":"user_guide/battery/","title":"Battery","text":"<p>A <code>Battery</code> models an energy storage system in your portfolio. The optimizer decides when to charge and discharge it to minimize costs (or maximize revenue).</p>"},{"location":"user_guide/battery/#basic-usage","title":"Basic usage","text":"<pre><code>from odys.energy_system_models.assets.storage import Battery\n\nbattery = Battery(\n    name=\"bess\",\n    capacity=100.0,          # MWh of storage\n    max_power=50.0,           # MW charge/discharge limit\n    efficiency_charging=0.95,\n    efficiency_discharging=0.95,\n    soc_start=0.5,            # starts at 50%\n)\n</code></pre>"},{"location":"user_guide/battery/#fields","title":"Fields","text":"Field Type Required Default Description <code>name</code> <code>str</code> Yes - Unique identifier for the battery <code>capacity</code> <code>float</code> Yes - Total energy capacity (MWh) <code>max_power</code> <code>float</code> Yes - Maximum charge/discharge power (MW) <code>efficiency_charging</code> <code>float</code> Yes - Charging efficiency, between 0 and 1 <code>efficiency_discharging</code> <code>float</code> Yes - Discharging efficiency, between 0 and 1 <code>soc_start</code> <code>float</code> Yes - Initial state of charge, as a fraction of capacity (0-1) <code>soc_end</code> <code>float</code> No <code>None</code> Required final state of charge (0-1). If <code>None</code>, the optimizer is free to choose <code>soc_min</code> <code>float</code> No <code>0.0</code> Minimum allowed state of charge (0-1) <code>soc_max</code> <code>float</code> No <code>1.0</code> Maximum allowed state of charge (0-1) <code>degradation_cost</code> <code>float</code> No <code>None</code> Cost per MWh cycled through the battery <code>self_discharge_rate</code> <code>float</code> No <code>None</code> Fraction of stored energy lost per hour (0-1)"},{"location":"user_guide/battery/#state-of-charge-soc","title":"State of charge (SOC)","text":"<p>The SOC fields control how the battery's energy level behaves:</p> <ul> <li><code>soc_start</code> is where the battery begins. A value of <code>0.5</code> means it starts at 50% of its capacity.</li> <li><code>soc_end</code> constrains where the battery must end up. This is useful when you want to ensure the battery isn't fully drained at the end of the optimization horizon.</li> <li><code>soc_min</code> and <code>soc_max</code> set the operating range. For example, if you don't want to go below 20% or above 90%:</li> </ul> <pre><code>battery = Battery(\n    name=\"bess\",\n    capacity=100.0,\n    max_power=50.0,\n    efficiency_charging=0.90,\n    efficiency_discharging=0.85,\n    soc_start=0.5,\n    soc_end=0.5,\n    soc_min=0.2,\n    soc_max=0.9,\n)\n</code></pre> <p>Note</p> <p><code>soc_start</code> and <code>soc_end</code> must fall within the <code>[soc_min, soc_max]</code> range. Pydantic validation will catch this if you get it wrong.</p>"},{"location":"user_guide/battery/#efficiency","title":"Efficiency","text":"<p>Charging and discharging efficiencies are applied separately. If you charge 10 MWh with 90% efficiency, 9 MWh actually goes into the battery. If you then discharge those 9 MWh at 85% efficiency, you get 7.65 MWh out.</p> <p>This means the round-trip efficiency is <code>efficiency_charging * efficiency_discharging</code>.</p>"},{"location":"user_guide/battery/#degradation-cost","title":"Degradation cost","text":"<p>If you want the optimizer to account for battery wear, set a <code>degradation_cost</code>:</p> <pre><code>battery = Battery(\n    name=\"bess\",\n    capacity=100.0,\n    max_power=50.0,\n    efficiency_charging=0.95,\n    efficiency_discharging=0.95,\n    soc_start=0.5,\n    degradation_cost=5.0,  # 5 currency units per MWh cycled\n)\n</code></pre> <p>This adds a cost penalty for each MWh that flows through the battery, discouraging unnecessary cycling.</p>"},{"location":"user_guide/battery/#results","title":"Results","text":"<p>After optimization, access battery results through <code>result.batteries</code>:</p> <pre><code>result = energy_system.optimize()\n\nresult.batteries.net_power        # charge/discharge per timestep\nresult.batteries.state_of_charge  # SOC at each timestep\n</code></pre> <p>Positive <code>net_power</code> means discharging, negative means charging.</p>"},{"location":"user_guide/energy_system/","title":"EnergySystem","text":"<p><code>EnergySystem</code> is the main entry point for setting up and running an optimization. You give it a portfolio of assets, scenario data, and time configuration -- then call <code>.optimize()</code>.</p>"},{"location":"user_guide/energy_system/#basic-usage","title":"Basic usage","text":"<pre><code>from datetime import timedelta\n\nfrom odys.energy_system import EnergySystem\nfrom odys.energy_system_models.assets.generator import PowerGenerator\nfrom odys.energy_system_models.assets.load import Load\nfrom odys.energy_system_models.assets.portfolio import AssetPortfolio\nfrom odys.energy_system_models.scenarios import Scenario\n\ngenerator = PowerGenerator(name=\"gen\", nominal_power=100.0, variable_cost=50.0)\nload = Load(name=\"demand\")\n\nportfolio = AssetPortfolio()\nportfolio.add_asset(generator)\nportfolio.add_asset(load)\n\nenergy_system = EnergySystem(\n    portfolio=portfolio,\n    scenarios=Scenario(\n        load_profiles={\"demand\": [60, 90, 40, 70]},\n    ),\n    timestep=timedelta(hours=1),\n    number_of_steps=4,\n    power_unit=\"MW\",\n)\n\nresult = energy_system.optimize()\n</code></pre>"},{"location":"user_guide/energy_system/#constructor-parameters","title":"Constructor parameters","text":"Parameter Type Required Default Description <code>portfolio</code> <code>AssetPortfolio</code> Yes - The collection of energy assets <code>scenarios</code> <code>Scenario</code> or <code>list[StochasticScenario]</code> Yes - Scenario data (load profiles, prices, capacity profiles) <code>timestep</code> <code>timedelta</code> Yes - Duration of each time period <code>number_of_steps</code> <code>int</code> Yes - How many timesteps to optimize over <code>power_unit</code> <code>str</code> Yes - Unit for power values: <code>\"W\"</code>, <code>\"kW\"</code>, or <code>\"MW\"</code> <code>markets</code> <code>EnergyMarket</code> or <code>list[EnergyMarket]</code> or <code>None</code> No <code>None</code> Energy markets for buying/selling"},{"location":"user_guide/energy_system/#scenarios","title":"Scenarios","text":"<p>For a single deterministic scenario, use <code>Scenario</code>:</p> <pre><code>from odys.energy_system_models.scenarios import Scenario\n\nscenario = Scenario(\n    load_profiles={\"demand\": [60, 90, 40, 70]},\n    available_capacity_profiles={\"gen\": [100, 80, 100, 100]},\n)\n</code></pre> <p>For stochastic optimization with multiple scenarios, pass a list of <code>StochasticScenario</code>:</p> <pre><code>from odys.energy_system_models.scenarios import StochasticScenario\n\nscenarios = [\n    StochasticScenario(\n        name=\"low_wind\",\n        probability=0.3,\n        load_profiles={\"demand\": [80, 90, 70, 60]},\n        available_capacity_profiles={\"wind\": [30, 20, 40, 25]},\n    ),\n    StochasticScenario(\n        name=\"high_wind\",\n        probability=0.7,\n        load_profiles={\"demand\": [80, 90, 70, 60]},\n        available_capacity_profiles={\"wind\": [120, 140, 100, 130]},\n    ),\n]\n</code></pre> <p>See Stochastic Optimization for more details.</p>"},{"location":"user_guide/energy_system/#adding-markets","title":"Adding markets","text":"<p>To include energy markets, pass them via the <code>markets</code> parameter:</p> <pre><code>from odys.energy_system_models.markets import EnergyMarket\n\nenergy_system = EnergySystem(\n    portfolio=portfolio,\n    markets=(\n        EnergyMarket(name=\"sdac\", max_trading_volume_per_step=150),\n        EnergyMarket(name=\"sidc\", max_trading_volume_per_step=100),\n    ),\n    scenarios=scenario,\n    timestep=timedelta(hours=1),\n    number_of_steps=4,\n    power_unit=\"MW\",\n)\n</code></pre> <p>Market prices are specified in the scenario, not on the market object. See Market for details.</p>"},{"location":"user_guide/energy_system/#running-the-optimization","title":"Running the optimization","text":"<p>Call <code>.optimize()</code> to build and solve the mathematical model:</p> <pre><code>result = energy_system.optimize()\n</code></pre> <p>This returns an <code>OptimizationResults</code> object. See Optimization for how to read and interpret the results.</p>"},{"location":"user_guide/energy_system/#what-happens-under-the-hood","title":"What happens under the hood","text":"<p>When you call <code>.optimize()</code>, odys:</p> <ol> <li>Validates the full system configuration (asset names match scenario profiles, probabilities sum to 1, etc.)</li> <li>Builds a mixed-integer linear program (MILP) using linopy</li> <li>Solves it with the HiGHS solver</li> <li>Wraps the solution in an <code>OptimizationResults</code> object</li> </ol> <p>You don't need to interact with any of these internals -- but if you're curious, the API Reference has the full details.</p>"},{"location":"user_guide/load/","title":"Load","text":"<p>A <code>Load</code> represents a demand that the energy system needs to satisfy. Loads come in two flavors: fixed and flexible.</p>"},{"location":"user_guide/load/#basic-usage","title":"Basic usage","text":"<p>The simplest case is a fixed load -- the system must produce exactly this much power at each timestep:</p> <pre><code>from odys.energy_system_models.assets.load import Load\n\nload = Load(name=\"demand\")\n</code></pre> <p>That's it. The actual demand values are specified later in the <code>Scenario</code> via <code>load_profiles</code>.</p>"},{"location":"user_guide/load/#fields","title":"Fields","text":"Field Type Required Default Description <code>name</code> <code>str</code> Yes - Unique identifier for the load <code>type</code> <code>LoadType</code> No <code>\"fixed\"</code> Either <code>\"fixed\"</code> or <code>\"flexible\"</code> <code>variable_cost_to_increase</code> <code>float</code> No <code>None</code> Cost per MWh for increasing load above baseline (flexible only) <code>variable_cost_to_decrease</code> <code>float</code> No <code>None</code> Cost per MWh for decreasing load below baseline (flexible only)"},{"location":"user_guide/load/#fixed-loads","title":"Fixed loads","text":"<p>A fixed load must be met exactly. The optimizer can't adjust it -- it has to dispatch generators and batteries to match.</p> <pre><code>load = Load(name=\"factory_demand\")\n</code></pre> <p>Then in your scenario:</p> <pre><code>from odys.energy_system_models.scenarios import Scenario\n\nscenario = Scenario(\n    load_profiles={\"factory_demand\": [100, 120, 80, 90]},\n)\n</code></pre> <p>The key in <code>load_profiles</code> must match the load's <code>name</code>.</p>"},{"location":"user_guide/load/#flexible-loads","title":"Flexible loads","text":"<p>A flexible load gives the optimizer some room to adjust demand up or down, but at a cost:</p> <pre><code>from odys.energy_system_models.assets.load import Load, LoadType\n\nflexible_load = Load(\n    name=\"adjustable_demand\",\n    type=LoadType.Flexible,\n    variable_cost_to_increase=30.0,\n    variable_cost_to_decrease=20.0,\n)\n</code></pre> <p>Warning</p> <p>For flexible loads, both <code>variable_cost_to_increase</code> and <code>variable_cost_to_decrease</code> are required. Pydantic will raise a validation error if you set the type to <code>\"flexible\"</code> without providing both costs.</p>"},{"location":"user_guide/load/#load-profiles","title":"Load profiles","text":"<p>The actual demand timeseries is always provided through a <code>Scenario</code>, not on the <code>Load</code> object itself. This keeps the asset definition clean and lets you reuse the same load across different scenarios:</p> <pre><code>from odys.energy_system_models.scenarios import Scenario\n\nscenario = Scenario(\n    load_profiles={\n        \"demand\": [60, 90, 40, 70],\n    },\n)\n</code></pre> <p>For multiple loads, just add more entries:</p> <pre><code>scenario = Scenario(\n    load_profiles={\n        \"factory\": [100, 120, 80, 90],\n        \"office\": [20, 25, 15, 20],\n    },\n)\n</code></pre>"},{"location":"user_guide/market/","title":"Market","text":"<p>An <code>EnergyMarket</code> represents an electricity market where your portfolio can buy and/or sell energy. This is how you model revenue from selling excess generation or purchasing power when it's cheaper than running your own assets.</p>"},{"location":"user_guide/market/#basic-usage","title":"Basic usage","text":"<pre><code>from odys.energy_system_models.markets import EnergyMarket\n\nmarket = EnergyMarket(\n    name=\"day_ahead\",\n    max_trading_volume_per_step=150.0,\n)\n</code></pre> <p>By default, the market allows both buying and selling up to the specified volume per timestep.</p>"},{"location":"user_guide/market/#fields","title":"Fields","text":"Field Type Required Default Description <code>name</code> <code>str</code> Yes - Unique identifier for the market <code>max_trading_volume_per_step</code> <code>float</code> Yes - Maximum volume that can be traded per timestep (MW) <code>trade_direction</code> <code>TradeDirection</code> No <code>\"both\"</code> Allowed trade directions: <code>\"buy\"</code>, <code>\"sell\"</code>, or <code>\"both\"</code> <code>stage_fixed</code> <code>bool</code> No <code>False</code> If <code>True</code>, trading decisions are fixed across all scenarios"},{"location":"user_guide/market/#trade-direction","title":"Trade direction","text":"<p>You can restrict which way the market trades:</p> <pre><code>from odys.energy_system_models.markets import EnergyMarket, TradeDirection\n\n# Can only sell into this market\nsell_only = EnergyMarket(\n    name=\"feed_in\",\n    max_trading_volume_per_step=100.0,\n    trade_direction=TradeDirection.SELL,\n)\n\n# Can only buy from this market\nbuy_only = EnergyMarket(\n    name=\"backup_supply\",\n    max_trading_volume_per_step=50.0,\n    trade_direction=TradeDirection.BUY,\n)\n</code></pre>"},{"location":"user_guide/market/#stage-fixed-decisions","title":"Stage-fixed decisions","text":"<p>When <code>stage_fixed=True</code>, the optimizer must commit to the same trading volumes across all stochastic scenarios. This models markets where you need to lock in your position before uncertainty is resolved -- like a day-ahead market where bids are placed before you know the actual wind/solar output.</p> <pre><code>day_ahead = EnergyMarket(\n    name=\"day_ahead\",\n    max_trading_volume_per_step=150.0,\n    stage_fixed=True,  # same volumes in all scenarios\n)\n\nintraday = EnergyMarket(\n    name=\"intraday\",\n    max_trading_volume_per_step=50.0,\n    stage_fixed=False,  # can adjust per scenario (default)\n)\n</code></pre> <p>This is particularly useful in stochastic optimization setups.</p>"},{"location":"user_guide/market/#market-prices","title":"Market prices","text":"<p>Prices are provided through the <code>Scenario</code> (or <code>StochasticScenario</code>), not on the market object itself:</p> <pre><code>from odys.energy_system_models.scenarios import Scenario\n\nscenario = Scenario(\n    market_prices={\n        \"day_ahead\": [50, 55, 45, 60, 70, 65, 50],\n    },\n    load_profiles={\"load\": [100, 120, 80, 90, 110, 100, 95]},\n)\n</code></pre> <p>The key must match the market's <code>name</code>.</p>"},{"location":"user_guide/market/#multiple-markets","title":"Multiple markets","text":"<p>You can pass multiple markets to the <code>EnergySystem</code>:</p> <pre><code>from odys.energy_system import EnergySystem\n\nenergy_system = EnergySystem(\n    portfolio=portfolio,\n    markets=(\n        EnergyMarket(name=\"sdac\", max_trading_volume_per_step=150),\n        EnergyMarket(name=\"sidc1\", max_trading_volume_per_step=100),\n        EnergyMarket(name=\"sidc2\", max_trading_volume_per_step=50),\n    ),\n    scenarios=scenario,\n    timestep=timedelta(minutes=30),\n    number_of_steps=7,\n    power_unit=\"MW\",\n)\n</code></pre>"},{"location":"user_guide/market/#results","title":"Results","text":"<p>After optimization, access market results through <code>result.markets</code>:</p> <pre><code>result = energy_system.optimize()\n\nresult.markets.sell_volume  # energy sold per market per timestep\nresult.markets.buy_volume   # energy bought per market per timestep\n</code></pre> <p>Each of these is a <code>pandas.DataFrame</code>.</p>"},{"location":"user_guide/multi_stage/","title":"Multi-stage Optimization","text":"<p>Coming soon</p> <p>Multi-stage optimization is planned but not yet implemented. This page describes the concept for context.</p>"},{"location":"user_guide/multi_stage/#what-is-multi-stage-optimization","title":"What is multi-stage optimization?","text":"<p>In stochastic optimization, you make decisions considering multiple scenarios, but all decisions are made at once (two-stage: decide now, then observe uncertainty).</p> <p>Multi-stage optimization extends this to a sequence of decision points over time. At each stage, you observe new information and can adjust your decisions accordingly. This models real-world operations more closely -- for example, you might bid in the day-ahead market today, then adjust in the intraday market tomorrow once you have better forecasts.</p>"},{"location":"user_guide/multi_stage/#how-it-relates-to-stage_fixed","title":"How it relates to <code>stage_fixed</code>","text":"<p>The <code>stage_fixed</code> parameter on <code>EnergyMarket</code> is a first step toward multi-stage behavior. Markets with <code>stage_fixed=True</code> represent earlier decision stages where you commit before uncertainty is resolved. Markets without it represent later stages where you can react to the realized scenario.</p> <p>When full multi-stage support arrives, you'll be able to define an explicit sequence of stages, each with its own information set and decision variables.</p>"},{"location":"user_guide/multi_stage/#stay-tuned","title":"Stay tuned","text":"<p>Follow the GitHub repository for updates on this feature.</p>"},{"location":"user_guide/optimization/","title":"Optimization","text":"<p>This page explains what happens when you call <code>energy_system.optimize()</code> -- the objective function, the constraints, and how to read the results.</p>"},{"location":"user_guide/optimization/#objective-function","title":"Objective function","text":"<p>Odys minimizes the total system cost (or equivalently, maximizes profit). The objective has two components:</p> <p>Operating costs (minimized):</p> <ul> <li>Generator variable costs: <code>power_output * variable_cost</code> for each generator at each timestep</li> <li>Startup costs: <code>startup_cost</code> each time a generator turns on</li> </ul> <p>Market revenue (maximized):</p> <ul> <li>Revenue from selling energy: <code>sell_volume * market_price</code></li> <li>Cost of buying energy: <code>buy_volume * market_price</code></li> </ul> <p>The optimizer finds the dispatch schedule that produces the best net profit across all timesteps (and all scenarios, if you're using stochastic optimization).</p>"},{"location":"user_guide/optimization/#constraints","title":"Constraints","text":"<p>The optimizer respects these constraints:</p>"},{"location":"user_guide/optimization/#power-balance","title":"Power balance","text":"<p>At every timestep, supply must equal demand:</p> <pre><code>generator_output + battery_discharge + market_buys\n= load + battery_charge + market_sells\n</code></pre> <p>This is the fundamental constraint -- the system has to balance.</p>"},{"location":"user_guide/optimization/#generator-constraints","title":"Generator constraints","text":"<ul> <li>Max power: Output can't exceed <code>nominal_power * status</code></li> <li>Min power: When on, output must be at least <code>min_power</code></li> <li>Ramp up/down: Change in output between consecutive steps is bounded</li> <li>Min up time: Once on, the generator stays on for at least <code>min_up_time</code> steps</li> <li>Startup/shutdown logic: Binary variables track when generators turn on and off</li> <li>Available capacity: If <code>available_capacity_profiles</code> is provided, output is capped per timestep</li> </ul>"},{"location":"user_guide/optimization/#battery-constraints","title":"Battery constraints","text":"<ul> <li>SOC tracking: State of charge is updated based on charge/discharge and efficiency</li> <li>SOC bounds: SOC stays within <code>[soc_min, soc_max]</code></li> <li>Initial/final SOC: Honored as set on the <code>Battery</code> object</li> <li>Power limits: Charge and discharge can't exceed <code>max_power</code></li> </ul>"},{"location":"user_guide/optimization/#market-constraints","title":"Market constraints","text":"<ul> <li>Volume limits: Buy/sell volume per timestep can't exceed <code>max_trading_volume_per_step</code></li> <li>Trade direction: If a market is buy-only or sell-only, the other direction is zero</li> <li>Non-anticipativity: For <code>stage_fixed</code> markets, trading volumes are the same across all scenarios</li> </ul>"},{"location":"user_guide/optimization/#reading-results","title":"Reading results","text":"<p>The <code>optimize()</code> call returns an <code>OptimizationResults</code> object:</p> <pre><code>result = energy_system.optimize()\n</code></pre>"},{"location":"user_guide/optimization/#solver-status","title":"Solver status","text":"<pre><code>result.solver_status         # \"ok\" if the solver found a solution\nresult.termination_condition # \"optimal\" if it's the best possible solution\n</code></pre>"},{"location":"user_guide/optimization/#asset-specific-results","title":"Asset-specific results","text":"<p>Each asset type has its own results container:</p> <pre><code># Generators\nresult.generators.power     # MW dispatched per timestep\nresult.generators.status    # on/off (1/0)\nresult.generators.startup   # startup events\nresult.generators.shutdown  # shutdown events\n\n# Batteries\nresult.batteries.net_power        # positive = discharging, negative = charging\nresult.batteries.state_of_charge  # SOC at each timestep\n\n# Markets\nresult.markets.sell_volume  # MW sold per market per timestep\nresult.markets.buy_volume   # MW bought per market per timestep\n</code></pre> <p>All of these are <code>pandas.DataFrame</code> objects, so you can use the full pandas API to slice, filter, and plot.</p>"},{"location":"user_guide/optimization/#combined-dataframe","title":"Combined DataFrame","text":"<p>For a single view of everything:</p> <pre><code>df = result.to_dataframe\n</code></pre> <p>This gives you a multi-indexed DataFrame with all variables, units, and timesteps. For deterministic scenarios, the scenario index level is dropped automatically.</p> <p>Tip</p> <p>If you're working in a notebook, <code>result.to_dataframe</code> is usually the quickest way to see what the optimizer did. You can export it with <code>.to_csv()</code> or plot it directly.</p>"},{"location":"user_guide/power_generator/","title":"PowerGenerator","text":"<p>A <code>PowerGenerator</code> represents any dispatchable power source in your energy system -- think gas turbines, diesel generators, or even a simplified solar/wind unit with a fixed capacity.</p>"},{"location":"user_guide/power_generator/#basic-usage","title":"Basic usage","text":"<pre><code>from odys.energy_system_models.assets.generator import PowerGenerator\n\ngen = PowerGenerator(\n    name=\"gas_turbine\",\n    nominal_power=100.0,\n    variable_cost=50.0,\n)\n</code></pre> <p>That's really all you need. The optimizer will figure out the dispatch (how much power to produce at each timestep) to minimize total cost while meeting demand.</p>"},{"location":"user_guide/power_generator/#fields","title":"Fields","text":"Field Type Required Default Description <code>name</code> <code>str</code> Yes - Unique identifier for the generator <code>nominal_power</code> <code>float</code> Yes - Maximum power output (in your chosen power unit) <code>variable_cost</code> <code>float</code> Yes - Cost per unit of energy produced (currency/MWh) <code>min_power</code> <code>float</code> No <code>0.0</code> Minimum power output when the generator is on <code>ramp_up</code> <code>float</code> No <code>None</code> Max increase in power per hour <code>ramp_down</code> <code>float</code> No <code>None</code> Max decrease in power per hour <code>min_up_time</code> <code>int</code> No <code>1</code> Minimum number of timesteps the generator must stay on <code>min_down_time</code> <code>int</code> No <code>1</code> Minimum number of timesteps the generator must stay off <code>startup_cost</code> <code>float</code> No <code>0.0</code> Cost incurred each time the generator starts up <code>shutdown_cost</code> <code>float</code> No <code>None</code> Cost incurred each time the generator shuts down"},{"location":"user_guide/power_generator/#ramp-constraints","title":"Ramp constraints","text":"<p>If your generator can't change output instantly, set ramp limits:</p> <pre><code>gen = PowerGenerator(\n    name=\"slow_gen\",\n    nominal_power=200.0,\n    variable_cost=30.0,\n    ramp_up=50.0,   # can increase by at most 50 MW/h\n    ramp_down=40.0,  # can decrease by at most 40 MW/h\n)\n</code></pre> <p>When <code>ramp_up</code> or <code>ramp_down</code> is <code>None</code> (the default), there's no ramp constraint -- the generator can jump from 0 to full power in a single step.</p>"},{"location":"user_guide/power_generator/#minimum-updown-times","title":"Minimum up/down times","text":"<p>These prevent the optimizer from toggling the generator on and off every timestep:</p> <pre><code>gen = PowerGenerator(\n    name=\"coal_plant\",\n    nominal_power=500.0,\n    variable_cost=25.0,\n    min_up_time=4,   # once on, stays on for at least 4 steps\n    min_down_time=2,  # once off, stays off for at least 2 steps\n)\n</code></pre>"},{"location":"user_guide/power_generator/#startup-and-shutdown-costs","title":"Startup and shutdown costs","text":"<p>You can penalize switching the generator on or off:</p> <pre><code>gen = PowerGenerator(\n    name=\"peaker\",\n    nominal_power=50.0,\n    variable_cost=80.0,\n    startup_cost=500.0,\n    shutdown_cost=100.0,\n)\n</code></pre> <p>This makes the optimizer think twice before toggling the generator, which is realistic for many thermal plants.</p>"},{"location":"user_guide/power_generator/#available-capacity-profiles","title":"Available capacity profiles","text":"<p>In a <code>Scenario</code>, you can limit the generator's available capacity per timestep using <code>available_capacity_profiles</code>. This is useful for modeling things like planned maintenance or variable renewable output:</p> <pre><code>from odys.energy_system_models.scenarios import Scenario\n\nscenario = Scenario(\n    available_capacity_profiles={\n        \"gas_turbine\": [100, 100, 50, 50, 100, 100, 100],\n    },\n    load_profiles={\"load\": [80, 90, 70, 60, 85, 95, 80]},\n)\n</code></pre> <p>The key in the dict must match the generator's <code>name</code>.</p>"},{"location":"user_guide/power_generator/#results","title":"Results","text":"<p>After optimization, access generator results through <code>result.generators</code>:</p> <pre><code>result = energy_system.optimize()\n\nresult.generators.power     # dispatch per timestep\nresult.generators.status    # on/off status (1 or 0)\nresult.generators.startup   # startup events\nresult.generators.shutdown  # shutdown events\n</code></pre> <p>Each of these is a <code>pandas.DataFrame</code>.</p>"},{"location":"user_guide/scenario/","title":"Scenario","text":"<p>A <code>Scenario</code> defines the operating conditions for your energy system -- load demand, generator availability, and market prices over time. It's the bridge between your asset definitions and the actual timeseries data the optimizer works with.</p>"},{"location":"user_guide/scenario/#basic-usage","title":"Basic usage","text":"<pre><code>from odys.energy_system_models.scenarios import Scenario\n\nscenario = Scenario(\n    load_profiles={\"demand\": [60, 90, 40, 70]},\n)\n</code></pre> <p>This tells the optimizer: \"here's what demand looks like over four timesteps.\" The key <code>\"demand\"</code> must match the <code>name</code> of a <code>Load</code> in your portfolio.</p>"},{"location":"user_guide/scenario/#fields","title":"Fields","text":"Field Type Required Default Description <code>load_profiles</code> <code>dict[str, list[float]]</code> No <code>None</code> Load values per timestep, keyed by load name <code>available_capacity_profiles</code> <code>dict[str, list[float]]</code> No <code>None</code> Max available capacity per timestep, keyed by generator name <code>market_prices</code> <code>dict[str, list[float]]</code> No <code>None</code> Market prices per timestep, keyed by market name <p>All fields are optional -- you only include what you need. If a field is omitted, the optimizer won't apply that constraint (e.g., generators without an <code>available_capacity_profiles</code> entry can produce up to their <code>nominal_power</code>).</p>"},{"location":"user_guide/scenario/#load-profiles","title":"Load profiles","text":"<p>Specify how much power each load demands at each timestep:</p> <pre><code>scenario = Scenario(\n    load_profiles={\n        \"factory\": [100, 120, 80, 90],\n        \"office\": [20, 25, 15, 20],\n    },\n)\n</code></pre> <p>The keys must match the <code>name</code> of a Load in your portfolio.</p>"},{"location":"user_guide/scenario/#available-capacity-profiles","title":"Available capacity profiles","text":"<p>Cap the output of specific generators over time. This is how you model variable renewable generation like wind or solar:</p> <pre><code>scenario = Scenario(\n    available_capacity_profiles={\n        \"wind_farm\": [80, 60, 90, 70],\n        \"solar\": [0, 50, 80, 30],\n    },\n    load_profiles={\"demand\": [100, 120, 80, 90]},\n)\n</code></pre> <p>The keys must match the <code>name</code> of a PowerGenerator in your portfolio. At each timestep, the generator can't produce more than the value specified here (or its <code>nominal_power</code>, whichever is lower).</p>"},{"location":"user_guide/scenario/#market-prices","title":"Market prices","text":"<p>Provide price timeseries for each Market:</p> <pre><code>scenario = Scenario(\n    market_prices={\n        \"day_ahead\": [50, 55, 45, 60],\n    },\n    load_profiles={\"demand\": [100, 120, 80, 90]},\n)\n</code></pre> <p>The keys must match the <code>name</code> of an <code>EnergyMarket</code> passed to the <code>EnergySystem</code>.</p>"},{"location":"user_guide/scenario/#putting-it-all-together","title":"Putting it all together","text":"<p>A scenario with all three fields might look like:</p> <pre><code>from odys.energy_system_models.scenarios import Scenario\n\nscenario = Scenario(\n    load_profiles={\n        \"demand\": [100, 120, 80, 90],\n    },\n    available_capacity_profiles={\n        \"wind_farm\": [80, 60, 90, 70],\n    },\n    market_prices={\n        \"day_ahead\": [50, 55, 45, 60],\n    },\n)\n</code></pre> <p>Then pass it to the EnergySystem:</p> <pre><code>energy_system = EnergySystem(\n    portfolio=portfolio,\n    scenarios=scenario,\n    timestep=timedelta(hours=1),\n    number_of_steps=4,\n    power_unit=\"MW\",\n)\n</code></pre>"},{"location":"user_guide/scenario/#when-you-need-multiple-scenarios","title":"When you need multiple scenarios","text":"<p>A single <code>Scenario</code> represents one deterministic future. If you want to optimize under uncertainty -- accounting for multiple possible outcomes -- use StochasticScenario instead.</p>"},{"location":"user_guide/stochastic/","title":"Stochastic Optimization","text":"<p>Real-world energy systems deal with uncertainty -- wind output varies, demand fluctuates, prices change. Stochastic optimization lets you make decisions that account for multiple possible futures simultaneously.</p>"},{"location":"user_guide/stochastic/#the-idea","title":"The idea","text":"<p>Instead of optimizing for a single forecast, you define multiple scenarios, each with a probability. The optimizer finds a dispatch plan that performs well across all scenarios, weighted by their likelihood.</p>"},{"location":"user_guide/stochastic/#stochasticscenario","title":"StochasticScenario","text":"<p>Each scenario extends the base <code>Scenario</code> with a name and a probability:</p> <pre><code>from odys.energy_system_models.scenarios import StochasticScenario\n\nlow_wind = StochasticScenario(\n    name=\"low_wind\",\n    probability=0.3,\n    available_capacity_profiles={\n        \"wind_farm\": [30, 20, 40, 25, 35, 30, 20],\n    },\n    load_profiles={\n        \"load\": [180, 180, 150, 50, 80, 90, 100],\n    },\n)\n\nhigh_wind = StochasticScenario(\n    name=\"high_wind\",\n    probability=0.7,\n    available_capacity_profiles={\n        \"wind_farm\": [120, 140, 100, 130, 110, 150, 140],\n    },\n    load_profiles={\n        \"load\": [180, 180, 150, 50, 80, 90, 100],\n    },\n)\n</code></pre>"},{"location":"user_guide/stochastic/#available-fields","title":"Available fields","text":"<p>Each <code>StochasticScenario</code> has:</p> Field Type Required Description <code>name</code> <code>str</code> Yes Unique name for the scenario <code>probability</code> <code>float</code> Yes Probability (0-1) of this scenario occurring <code>load_profiles</code> <code>dict[str, list[float]]</code> No Load values per timestep, keyed by load name <code>available_capacity_profiles</code> <code>dict[str, list[float]]</code> No Max available capacity per timestep, keyed by generator name <code>market_prices</code> <code>dict[str, list[float]]</code> No Market prices per timestep, keyed by market name <p>Warning</p> <p>Probabilities across all scenarios must sum to exactly 1.0. Scenario names must be unique. Odys validates both of these and raises a <code>ValueError</code> if they don't hold.</p>"},{"location":"user_guide/stochastic/#using-stochastic-scenarios","title":"Using stochastic scenarios","text":"<p>Pass a list of scenarios instead of a single <code>Scenario</code>:</p> <pre><code>from datetime import timedelta\n\nfrom odys.energy_system import EnergySystem\n\nenergy_system = EnergySystem(\n    portfolio=portfolio,\n    scenarios=[low_wind, high_wind],\n    timestep=timedelta(minutes=30),\n    number_of_steps=7,\n    power_unit=\"MW\",\n)\n\nresult = energy_system.optimize()\n</code></pre> <p>Everything else works the same -- the optimizer just considers multiple futures instead of one.</p>"},{"location":"user_guide/stochastic/#what-varies-across-scenarios","title":"What varies across scenarios","text":"<p>You can vary any combination of:</p> <ul> <li><code>available_capacity_profiles</code> -- model different wind/solar outputs</li> <li><code>load_profiles</code> -- model demand uncertainty</li> <li><code>market_prices</code> -- model price volatility</li> </ul> <p>Anything you don't include in a scenario stays unconstrained (e.g., if you don't specify <code>available_capacity_profiles</code>, generators can produce up to their <code>nominal_power</code> in that scenario).</p>"},{"location":"user_guide/stochastic/#scenario-vs-stochasticscenario","title":"Scenario vs StochasticScenario","text":"<code>Scenario</code> <code>StochasticScenario</code> Number Exactly one Two or more in a list Probability Implicit 1.0 Explicit, must sum to 1.0 Name Not needed Required, must be unique Use case Deterministic dispatch Decisions under uncertainty"},{"location":"user_guide/stochastic/#stage-fixed-decisions","title":"Stage-fixed decisions","text":"<p>When using stochastic optimization with markets, you can mark certain markets as <code>stage_fixed=True</code>. This means the optimizer must commit to the same trading volumes in that market across all scenarios -- modeling situations where you lock in a position before uncertainty resolves.</p> <pre><code>from odys.energy_system_models.markets import EnergyMarket\n\nday_ahead = EnergyMarket(\n    name=\"day_ahead\",\n    max_trading_volume_per_step=150.0,\n    stage_fixed=True,  # must be the same in all scenarios\n)\n\nintraday = EnergyMarket(\n    name=\"intraday\",\n    max_trading_volume_per_step=50.0,\n    # stage_fixed=False by default -- can differ per scenario\n)\n</code></pre> <p>See the Markets + Stochastic example for a full walkthrough.</p>"},{"location":"user_guide/stochastic/#results-with-multiple-scenarios","title":"Results with multiple scenarios","text":"<p>When you have multiple scenarios, the results DataFrames include a scenario dimension:</p> <pre><code>result = energy_system.optimize()\n\n# Generator power now has a scenario axis\nprint(result.generators.power)\n\n# The combined DataFrame includes the scenario level\nprint(result.to_dataframe)\n</code></pre> <p>For deterministic (single scenario) runs, the scenario level is dropped automatically so you don't have to deal with it.</p>"},{"location":"user_guide/stochastic_scenario/","title":"StochasticScenario","text":"<p>A <code>StochasticScenario</code> extends Scenario with a name and a probability, letting you model multiple possible futures. The optimizer finds a dispatch plan that performs well across all scenarios, weighted by how likely each one is.</p>"},{"location":"user_guide/stochastic_scenario/#basic-usage","title":"Basic usage","text":"<pre><code>from odys.energy_system_models.scenarios import StochasticScenario\n\nlow_wind = StochasticScenario(\n    name=\"low_wind\",\n    probability=0.3,\n    available_capacity_profiles={\n        \"wind_farm\": [30, 20, 40, 25],\n    },\n    load_profiles={\"demand\": [100, 120, 80, 90]},\n)\n\nhigh_wind = StochasticScenario(\n    name=\"high_wind\",\n    probability=0.7,\n    available_capacity_profiles={\n        \"wind_farm\": [120, 140, 100, 130],\n    },\n    load_profiles={\"demand\": [100, 120, 80, 90]},\n)\n</code></pre>"},{"location":"user_guide/stochastic_scenario/#fields","title":"Fields","text":"<p><code>StochasticScenario</code> inherits all fields from Scenario and adds two:</p> Field Type Required Default Description <code>name</code> <code>str</code> Yes - Unique identifier for the scenario <code>probability</code> <code>float</code> Yes - Probability (0-1) of this scenario occurring <code>load_profiles</code> <code>dict[str, list[float]]</code> No <code>None</code> Load values per timestep, keyed by load name <code>available_capacity_profiles</code> <code>dict[str, list[float]]</code> No <code>None</code> Max available capacity per timestep, keyed by generator name <code>market_prices</code> <code>dict[str, list[float]]</code> No <code>None</code> Market prices per timestep, keyed by market name"},{"location":"user_guide/stochastic_scenario/#validation-rules","title":"Validation rules","text":"<p>Odys enforces two rules when you pass a list of stochastic scenarios to the <code>EnergySystem</code>:</p> <ol> <li>Probabilities must sum to 1.0 -- if they don't, you'll get a <code>ValueError</code></li> <li>Names must be unique -- duplicated names also raise a <code>ValueError</code></li> </ol> <pre><code># This will fail: probabilities sum to 0.8\nscenarios = [\n    StochasticScenario(name=\"a\", probability=0.5, load_profiles={\"demand\": [100]}),\n    StochasticScenario(name=\"b\", probability=0.3, load_profiles={\"demand\": [100]}),\n]\n\n# This will fail: duplicate names\nscenarios = [\n    StochasticScenario(name=\"scenario\", probability=0.5, load_profiles={\"demand\": [100]}),\n    StochasticScenario(name=\"scenario\", probability=0.5, load_profiles={\"demand\": [100]}),\n]\n</code></pre>"},{"location":"user_guide/stochastic_scenario/#using-stochastic-scenarios","title":"Using stochastic scenarios","text":"<p>Pass a list of scenarios to the EnergySystem instead of a single <code>Scenario</code>:</p> <pre><code>from datetime import timedelta\n\nfrom odys.energy_system import EnergySystem\n\nenergy_system = EnergySystem(\n    portfolio=portfolio,\n    scenarios=[low_wind, high_wind],\n    timestep=timedelta(hours=1),\n    number_of_steps=4,\n    power_unit=\"MW\",\n)\n\nresult = energy_system.optimize()\n</code></pre> <p>Everything else works the same -- the optimizer just considers multiple futures instead of one.</p>"},{"location":"user_guide/stochastic_scenario/#what-can-vary-across-scenarios","title":"What can vary across scenarios","text":"<p>Each scenario can have different values for any combination of:</p> <ul> <li><code>available_capacity_profiles</code> -- model different wind/solar outputs</li> <li><code>load_profiles</code> -- model demand uncertainty</li> <li><code>market_prices</code> -- model price volatility</li> </ul> <p>This means you can capture several types of uncertainty in a single optimization run.</p>"},{"location":"user_guide/stochastic_scenario/#scenario-vs-stochasticscenario","title":"Scenario vs StochasticScenario","text":"<code>Scenario</code> <code>StochasticScenario</code> Number Exactly one Two or more in a list Probability Implicit 1.0 Explicit, must sum to 1.0 Name Not needed Required, must be unique Use case Deterministic dispatch Decisions under uncertainty"},{"location":"user_guide/stochastic_scenario/#next-steps","title":"Next steps","text":"<p>For a deeper dive into stochastic optimization concepts -- stage-fixed decisions, results with multiple scenarios, and how the optimizer weighs probabilities -- see Stochastic Optimization.</p>"}]}